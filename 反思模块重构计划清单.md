# ğŸ—ºï¸ DroidRun å¤±è´¥åˆ†æå‹åæ€æ¨¡å— - é¡¹ç›®å®æ–½è®¡åˆ’

åŸºäºåˆšæ‰çš„è®¾è®¡æ–¹æ¡ˆï¼Œæˆ‘å°†å®æ–½è¿‡ç¨‹åˆ’åˆ†ä¸º **6 ä¸ªæ¸è¿›å¼æ­¥éª¤**ï¼Œæ¯æ­¥éƒ½å¯ç‹¬ç«‹æµ‹è¯•å’ŒéªŒè¯ã€‚

---

## ğŸ“‹ Step 0ï¼šå‰æœŸå‡†å¤‡ï¼ˆ0.5å¤©ï¼‰

### **ç›®æ ‡**
äº†è§£ç°æœ‰ä»£ç ç»“æ„ï¼Œç¡®ä¿ä¸ç ´åç°æœ‰åŠŸèƒ½ã€‚

### **ä»»åŠ¡æ¸…å•**
- [ ] **ä»£ç å®¡æŸ¥**
  - é˜…è¯» [droid_agent.py](cci:7://file:///e:/WorkRelated/ResumeScreeningRelated/GUI/droidrun/droidrun/agent/droid/droid_agent.py:0:0-0:0) çš„å®Œæ•´æ‰§è¡Œæµç¨‹
  - ç†è§£ `Trajectory` æ•°æ®ç»“æ„
  - ç¡®è®¤ [UIStabilityChecker](cci:2://file:///e:/WorkRelated/ResumeScreeningRelated/GUI/droidrun/droidrun/agent/utils/ui_stability_checker.py:11:0-189:22) çš„å·¥ä½œæ–¹å¼
  - æŸ¥çœ‹ç°æœ‰çš„ [Reflector](cci:2://file:///e:/WorkRelated/ResumeScreeningRelated/GUI/droidrun/DigitalEmployee/Reflector_Agent/reflector.py:21:0-119:77) å®ç°ï¼ˆoneflows/reflector.pyï¼‰

- [ ] **ç¯å¢ƒå‡†å¤‡**
  - åˆ›å»ºåŠŸèƒ½åˆ†æ”¯ `feature/failure-reflection`
  - å‡†å¤‡æµ‹è¯•ç¯å¢ƒï¼ˆç¡®ä¿èƒ½è¿è¡Œç°æœ‰æµ‹è¯•ï¼‰
  - å‡†å¤‡å‡ ä¸ªå…¸å‹çš„å¤±è´¥åœºæ™¯ç”¨ä¾‹

- [ ] **æ–‡æ¡£å‡†å¤‡**
  - åˆ›å»º `docs/failure_reflection_design.md`ï¼ˆè®°å½•è®¾è®¡æ–¹æ¡ˆï¼‰
  - åˆ›å»º `docs/failure_reflection_implementation.md`ï¼ˆè®°å½•å®æ–½è¿›åº¦ï¼‰

### **è¾“å‡ºæˆæœ**
- âœ… åˆ†æ”¯åˆ›å»ºå®Œæˆ
- âœ… ç°æœ‰ä»£ç ç†è§£æ¸…æ™°
- âœ… æµ‹è¯•ç¯å¢ƒå°±ç»ª

---

## ğŸ—ï¸ Step 1ï¼šåŸºç¡€æ•°æ®ç»“æ„å’Œåæ€å™¨æ¡†æ¶ï¼ˆ1å¤©ï¼‰

### **ç›®æ ‡**
æ„å»ºåæ€æ¨¡å—çš„æ ¸å¿ƒéª¨æ¶ï¼Œä¸æ¶‰åŠä¸šåŠ¡é€»è¾‘é›†æˆã€‚

### **1.1 åˆ›å»ºæ¨¡å—ç›®å½•ç»“æ„**
```
droidrun/agent/reflection/
â”œâ”€â”€ __init__.py
â”œâ”€â”€ failure_reflector.py       # æ ¸å¿ƒåæ€å™¨
â”œâ”€â”€ reflection_types.py         # æ•°æ®ç±»å‹å®šä¹‰
â””â”€â”€ reflection_prompts.py       # æç¤ºè¯æ¨¡æ¿
```

### **1.2 å®ç°æ•°æ®ç±»å‹ï¼ˆreflection_types.pyï¼‰**

**æ–°å¢ç±»**ï¼š
```python
@dataclass
class FailureContext:
    """å¤±è´¥åœºæ™¯çš„å®Œæ•´ä¸Šä¸‹æ–‡"""
    failure_type: str
    goal: str
    failed_action: Optional[Dict]
    error_message: str
    error_step: int
    pre_ui_state: Optional[Dict]
    post_ui_state: Optional[Dict]
    recent_actions: List[Dict]
    # ... å…¶ä»–å­—æ®µ
    
    @classmethod
    def from_hot_start_failure(cls, ...):
        """ä»çƒ­å¯åŠ¨å¤±è´¥åˆ›å»ºä¸Šä¸‹æ–‡"""
        
    @classmethod
    def from_action_failure(cls, ...):
        """ä»å•ä¸ªåŠ¨ä½œå¤±è´¥åˆ›å»ºä¸Šä¸‹æ–‡"""

@dataclass
class FailureReflection:
    """åæ€ç»“æœ"""
    problem_type: str
    root_cause: str
    ui_changed: bool
    ui_change_summary: Optional[str]
    recommended_strategy: str
    specific_advice: str
    suggested_action: Optional[Dict]
    confidence: float
    
    def to_dict(self) -> Dict:
        """è½¬æ¢ä¸ºå­—å…¸ï¼ˆç”¨äºæ—¥å¿—å’Œåºåˆ—åŒ–ï¼‰"""
        
    @classmethod
    def from_dict(cls, data: Dict):
        """ä»å­—å…¸åˆ›å»ºï¼ˆç”¨äºæµ‹è¯•ï¼‰"""
```

### **1.3 å®ç°åæ€å™¨éª¨æ¶ï¼ˆfailure_reflector.pyï¼‰**

```python
class FailureReflector:
    """å¤±è´¥åˆ†æåæ€å™¨"""
    
    def __init__(self, llm, debug: bool = False):
        self.llm = llm
        self.debug = debug
        self._init_prompts()
    
    def _init_prompts(self):
        """åˆå§‹åŒ–æç¤ºè¯"""
        # ä» reflection_prompts.py åŠ è½½
    
    async def analyze_failure(
        self, 
        context: FailureContext
    ) -> FailureReflection:
        """åˆ†æå¤±è´¥å¹¶ç”Ÿæˆåæ€
        
        è¿™æ˜¯æ ¸å¿ƒæ–¹æ³•ï¼Œä½†ç°åœ¨å…ˆè¿”å› mock æ•°æ®
        """
        # TODO: å®ç° LLM è°ƒç”¨é€»è¾‘
        # ç°é˜¶æ®µè¿”å›å›ºå®šçš„åæ€ç»“æœç”¨äºæµ‹è¯•
        return FailureReflection(
            problem_type="ui_changed",
            root_cause="Mock reason for testing",
            ui_changed=True,
            ui_change_summary="Mock UI change",
            recommended_strategy="fallback_cold_start",
            specific_advice="Mock advice",
            suggested_action=None,
            confidence=0.8
        )
    
    def _analyze_ui_change(
        self, 
        pre_ui: Optional[Dict], 
        post_ui: Optional[Dict]
    ) -> Tuple[bool, Optional[str]]:
        """å¯¹æ¯” UI å‰åçŠ¶æ€ï¼ˆè¾…åŠ©æ–¹æ³•ï¼‰"""
        # TODO: å®ç° UI å¯¹æ¯”é€»è¾‘
        pass
```

### **1.4 æç¤ºè¯æ¨¡æ¿ï¼ˆreflection_prompts.pyï¼‰**

```python
HOT_START_FAILURE_PROMPT = """
ä½ æ˜¯ä¸€ä¸ªåˆ†æ Android UI è‡ªåŠ¨åŒ–ä»»åŠ¡å¤±è´¥çš„åæ€ AIã€‚

å½“å‰åœºæ™¯ï¼šçƒ­å¯åŠ¨æ‰§è¡Œå¤±è´¥
...ï¼ˆå®Œæ•´æç¤ºè¯ï¼‰
"""

COLD_START_FAILURE_PROMPT = """
å½“å‰åœºæ™¯ï¼šå†·å¯åŠ¨åŠ¨ä½œæ‰§è¡Œå¤±è´¥
...
"""

# å…¶ä»–æç¤ºè¯æ¨¡æ¿...
```

### **1.5 å•å…ƒæµ‹è¯•ï¼ˆtests/test_failure_reflector.pyï¼‰**

```python
import pytest
from droidrun.agent.reflection import FailureContext, FailureReflector

def test_failure_context_creation():
    """æµ‹è¯• FailureContext åˆ›å»º"""
    context = FailureContext.from_hot_start_failure(
        goal="æµ‹è¯•ä»»åŠ¡",
        failed_action={"action": "tap_by_index", "params": {"index": 19}},
        error_message="Element not found",
        error_step=3
    )
    assert context.failure_type == "hot_start"
    assert context.error_step == 3

@pytest.mark.asyncio
async def test_reflector_basic(mock_llm):
    """æµ‹è¯•åæ€å™¨åŸºç¡€åŠŸèƒ½"""
    reflector = FailureReflector(llm=mock_llm)
    context = FailureContext(...)
    
    reflection = await reflector.analyze_failure(context)
    
    assert reflection.problem_type in ["ui_changed", "wrong_element", ...]
    assert reflection.confidence >= 0.0 and reflection.confidence <= 1.0
```

### **è¾“å‡ºæˆæœ**
- âœ… å®Œæ•´çš„æ•°æ®ç±»å‹å®šä¹‰
- âœ… åæ€å™¨æ¡†æ¶ï¼ˆè¿”å› mock æ•°æ®ï¼‰
- âœ… æç¤ºè¯æ¨¡æ¿æ–‡ä»¶
- âœ… å•å…ƒæµ‹è¯•é€šè¿‡ï¼ˆ>=80% è¦†ç›–ç‡ï¼‰
- âœ… ä»£ç å¯å¯¼å…¥ï¼Œä¸æŠ¥é”™

---

## ğŸ”Œ Step 2ï¼šå®ç°æ ¸å¿ƒåæ€é€»è¾‘ï¼ˆ1.5å¤©ï¼‰

### **ç›®æ ‡**
å®ç°çœŸæ­£çš„ LLM è°ƒç”¨å’Œ UI åˆ†æé€»è¾‘ï¼Œä½¿åæ€å™¨èƒ½äº§ç”Ÿæœ‰æ•ˆç»“æœã€‚

### **2.1 å®ç° UI çŠ¶æ€å¯¹æ¯”ï¼ˆfailure_reflector.pyï¼‰**

```python
def _analyze_ui_change(
    self, 
    pre_ui: Optional[Dict], 
    post_ui: Optional[Dict]
) -> Tuple[bool, Optional[str]]:
    """å¯¹æ¯”æ‰§è¡Œå‰åçš„ UI çŠ¶æ€"""
    if not pre_ui or not post_ui:
        return False, None
    
    # 1. å¯¹æ¯”å…ƒç´ æ•°é‡
    pre_elements = pre_ui.get('elements', [])
    post_elements = post_ui.get('elements', [])
    
    if len(pre_elements) != len(post_elements):
        return True, f"å…ƒç´ æ•°é‡ä» {len(pre_elements)} å˜ä¸º {len(post_elements)}"
    
    # 2. å¯¹æ¯” UI hash
    pre_hash = self._calculate_ui_hash(pre_ui)
    post_hash = self._calculate_ui_hash(post_ui)
    
    if pre_hash != post_hash:
        # 3. è¯¦ç»†åˆ†æå˜åŒ–å†…å®¹
        changes = self._analyze_ui_differences(pre_elements, post_elements)
        return True, changes
    
    return False, None

def _calculate_ui_hash(self, ui_state: Dict) -> str:
    """è®¡ç®— UI çŠ¶æ€çš„ hashï¼ˆå¤ç”¨ UIStabilityChecker é€»è¾‘ï¼‰"""
    # å¯ä»¥ç›´æ¥è°ƒç”¨ UIStabilityChecker.calculate_ui_hash
    pass

def _analyze_ui_differences(
    self, 
    pre_elements: List, 
    post_elements: List
) -> str:
    """è¯¦ç»†åˆ†æ UI å…ƒç´ çš„å˜åŒ–"""
    # å¯¹æ¯”æ–‡æœ¬ã€IDã€ç±»å‹ç­‰
    # è¿”å›äººç±»å¯è¯»çš„å˜åŒ–æè¿°
    pass
```

### **2.2 å®ç° LLM è°ƒç”¨é€»è¾‘**

```python
async def analyze_failure(
    self, 
    context: FailureContext
) -> FailureReflection:
    """åˆ†æå¤±è´¥å¹¶ç”Ÿæˆåæ€"""
    
    # 1. åˆ†æ UI å˜åŒ–ï¼ˆä¸éœ€è¦ LLMï¼‰
    ui_changed, ui_change_summary = self._analyze_ui_change(
        context.pre_ui_state, 
        context.post_ui_state
    )
    
    # 2. é€‰æ‹©æç¤ºè¯æ¨¡æ¿
    prompt = self._select_prompt(context.failure_type)
    
    # 3. æ„å»ºä¸Šä¸‹æ–‡æ¶ˆæ¯
    messages = self._build_messages(context, ui_changed, ui_change_summary)
    
    # 4. è°ƒç”¨ LLM
    try:
        response = await self._call_llm(messages)
        reflection = self._parse_llm_response(response)
        
        # 5. å¢å¼ºåæ€ç»“æœ
        reflection.ui_changed = ui_changed
        reflection.ui_change_summary = ui_change_summary
        
        return reflection
        
    except Exception as e:
        LoggingUtils.log_error("FailureReflector", "LLM call failed: {error}", error=e)
        # è¿”å›ä¿å®ˆçš„å›é€€ç­–ç•¥
        return self._create_fallback_reflection(context)

def _build_messages(
    self, 
    context: FailureContext,
    ui_changed: bool,
    ui_change_summary: Optional[str]
) -> List[Dict]:
    """æ„å»º LLM æ¶ˆæ¯"""
    system_prompt = self._get_system_prompt(context.failure_type)
    
    user_content_parts = [
        f"ä»»åŠ¡ç›®æ ‡: {context.goal}",
        f"å¤±è´¥æ­¥éª¤: ç¬¬ {context.error_step} æ­¥",
        f"å¤±è´¥åŠ¨ä½œ: {context.failed_action}",
        f"é”™è¯¯ä¿¡æ¯: {context.error_message}",
        f"UI æ˜¯å¦å˜åŒ–: {'æ˜¯' if ui_changed else 'å¦'}",
    ]
    
    if ui_change_summary:
        user_content_parts.append(f"UI å˜åŒ–è¯¦æƒ…: {ui_change_summary}")
    
    if context.recent_actions:
        user_content_parts.append(f"æœ€è¿‘åŠ¨ä½œ: {context.recent_actions}")
    
    # æ·»åŠ å½“å‰ UI çŠ¶æ€ï¼ˆç®€åŒ–ç‰ˆï¼Œé¿å… token è¿‡å¤šï¼‰
    if context.post_ui_state:
        simplified_ui = self._simplify_ui_state(context.post_ui_state)
        user_content_parts.append(f"å½“å‰ UI çŠ¶æ€: {simplified_ui}")
    
    return [
        {"role": "system", "content": system_prompt},
        {"role": "user", "content": "\n\n".join(user_content_parts)}
    ]

def _parse_llm_response(self, response: str) -> FailureReflection:
    """è§£æ LLM è¿”å›çš„ JSON"""
    try:
        # æ¸…ç† markdown æ ‡è®°
        content = response.strip()
        if content.startswith('```json'):
            content = content[7:-3]
        elif content.startswith('```'):
            content = content[3:-3]
        
        data = json.loads(content.strip())
        return FailureReflection.from_dict(data)
        
    except json.JSONDecodeError as e:
        LoggingUtils.log_error("FailureReflector", "JSON parse error: {error}", error=e)
        # é€’å½’é‡è¯•æˆ–è¿”å›é»˜è®¤å€¼
        raise
```

### **2.3 å®Œå–„æç¤ºè¯ï¼ˆreflection_prompts.pyï¼‰**

**æŒ‰ä¹‹å‰è®¾è®¡çš„å®Œæ•´æç¤ºè¯å®ç°**ï¼ŒåŒ…æ‹¬ï¼š
- ç³»ç»Ÿè§’è‰²å®šä¹‰
- åˆ†ææµç¨‹è¯´æ˜
- é—®é¢˜ç±»å‹åˆ†ç±»
- è¾“å‡ºæ ¼å¼è¦æ±‚
- ç¤ºä¾‹ï¼ˆfew-shotï¼‰

### **2.4 é›†æˆæµ‹è¯•ï¼ˆtests/test_failure_reflector_integration.pyï¼‰**

```python
@pytest.mark.asyncio
async def test_hot_start_failure_reflection(real_llm):
    """æµ‹è¯•çƒ­å¯åŠ¨å¤±è´¥åæ€ï¼ˆçœŸå® LLMï¼‰"""
    context = FailureContext.from_hot_start_failure(
        goal="ç”³è¯·å¹´å‡",
        failed_action={"action": "tap_by_index", "params": {"index": 19}},
        error_message="Element at index 19 not found",
        error_step=3,
        pre_ui_state=load_mock_ui_state("pre.json"),
        post_ui_state=load_mock_ui_state("post.json")
    )
    
    reflector = FailureReflector(llm=real_llm)
    reflection = await reflector.analyze_failure(context)
    
    # éªŒè¯åæ€ç»“æœ
    assert reflection.problem_type != ""
    assert reflection.root_cause != ""
    assert reflection.specific_advice != ""
    assert 0.0 <= reflection.confidence <= 1.0
    
    # æ‰“å°ç»“æœä¾›äººå·¥æ£€æŸ¥
    print(f"Problem: {reflection.problem_type}")
    print(f"Cause: {reflection.root_cause}")
    print(f"Advice: {reflection.specific_advice}")
```

### **è¾“å‡ºæˆæœ**
- âœ… å®Œæ•´çš„ UI å¯¹æ¯”é€»è¾‘
- âœ… çœŸå®çš„ LLM è°ƒç”¨
- âœ… JSON è§£æå’Œé”™è¯¯å¤„ç†
- âœ… å®Œæ•´çš„æç¤ºè¯æ¨¡æ¿
- âœ… é›†æˆæµ‹è¯•é€šè¿‡
- âœ… èƒ½äº§ç”Ÿæœ‰æ„ä¹‰çš„åæ€ç»“æœ

---

## ğŸ”— Step 3ï¼šé›†æˆåˆ°çƒ­å¯åŠ¨å¤±è´¥åœºæ™¯ï¼ˆ1å¤©ï¼‰

### **ç›®æ ‡**
åœ¨ [DroidAgent](cci:2://file:///e:/WorkRelated/ResumeScreeningRelated/GUI/droidrun/droidrun/agent/droid/droid_agent.py:84:0-2127:22) çš„çƒ­å¯åŠ¨å¤±è´¥å¤„é›†æˆåæ€æ¨¡å—ï¼Œå®ç°æœ€é«˜ä»·å€¼çš„åº”ç”¨åœºæ™¯ã€‚

### **3.1 ä¿®æ”¹ DroidAgent åˆå§‹åŒ–**

```python
# droid_agent.py __init__
def __init__(self, ...):
    # ç°æœ‰åˆå§‹åŒ–...
    
    # åˆå§‹åŒ–å¤±è´¥åæ€å™¨
    self.failure_reflection_enabled = self.config_manager.get(
        "agent.reflection.enabled", False
    )
    
    if self.failure_reflection_enabled:
        from droidrun.agent.reflection import FailureReflector
        self.failure_reflector = FailureReflector(
            llm=self.llm,
            debug=self.debug
        )
        LoggingUtils.log_info("DroidAgent", "âœ¨ Failure reflection enabled")
```

### **3.2 åœ¨çƒ­å¯åŠ¨å¤±è´¥å¤„é›†æˆåæ€**

```python
# droid_agent.py execute_task æ–¹æ³•ï¼ˆLine 347 é™„è¿‘ï¼‰

else:
    # çƒ­å¯åŠ¨å¤±è´¥ï¼Œå›é€€åˆ°å†·å¯åŠ¨
    LoggingUtils.log_warning("DroidAgent", "ğŸ”¥ â„ï¸ Hot start failed, falling back to cold start")
    
    # âœ¨ æ–°å¢ï¼šå¤±è´¥åæ€
    reflection_context_for_cold_start = None
    if self.failure_reflection_enabled and hasattr(self, 'failure_reflector'):
        try:
            LoggingUtils.log_info("DroidAgent", "ğŸ” Analyzing hot start failure...")
            
            # æ„å»ºå¤±è´¥ä¸Šä¸‹æ–‡
            failure_context = FailureContext.from_hot_start_failure(
                goal=self.goal,
                failed_action=self.pending_hot_actions[error_step] if error_step < len(self.pending_hot_actions) else None,
                error_message=reason,  # æ¥è‡ª _direct_execute_actions_async çš„è¿”å›å€¼
                error_step=error_step,
                pre_ui_state=self._get_recent_ui_state(-1),  # éœ€è¦ä¿å­˜å†å² UI
                post_ui_state=await self.tools_instance.get_state_async(include_screenshot=False),
                recent_actions=self.pending_hot_actions[:error_step],
                expected_action=self.pending_hot_actions[error_step] if error_step < len(self.pending_hot_actions) else None
            )
            
            # è°ƒç”¨åæ€å™¨
            reflection = await self.failure_reflector.analyze_failure(failure_context)
            
            # è®°å½•åæ€ç»“æœ
            LoggingUtils.log_info("DroidAgent", "ğŸ’¡ Problem: {type}", type=reflection.problem_type)
            LoggingUtils.log_info("DroidAgent", "ğŸ’¡ Root cause: {cause}", cause=reflection.root_cause)
            LoggingUtils.log_info("DroidAgent", "ğŸ’¡ Advice: {advice}", advice=reflection.specific_advice)
            LoggingUtils.log_info("DroidAgent", "ğŸ’¡ Confidence: {conf:.2f}", conf=reflection.confidence)
            
            # ä¿å­˜åæ€ç»“æœä¾›å†·å¯åŠ¨ä½¿ç”¨
            reflection_context_for_cold_start = reflection
            
        except Exception as e:
            LoggingUtils.log_warning("DroidAgent", "Failed to reflect on hot start failure: {error}", error=str(e))
            if self.debug:
                import traceback
                LoggingUtils.log_error("DroidAgent", "{trace}", trace=traceback.format_exc())
    
    # æ ¹æ®åæ€ç»“æœå†³å®šå†·å¯åŠ¨çš„ä»»åŠ¡æè¿°
    if reflection_context_for_cold_start and reflection_context_for_cold_start.confidence > 0.6:
        task_description = self._enhance_task_with_reflection(
            self.goal, 
            reflection_context_for_cold_start
        )
    else:
        task_description = self.goal
    
    task = Task(
        description=task_description,
        status=self.task_manager.STATUS_PENDING,
        agent_type="Default",
    )
    
    LoggingUtils.log_info("DroidAgent", "ğŸ”„ Cold start task created with {context}", 
                        context="reflection guidance" if reflection_context_for_cold_start else "original goal")
```

### **3.3 å®ç°è¾…åŠ©æ–¹æ³•**

```python
def _enhance_task_with_reflection(
    self, 
    original_goal: str, 
    reflection: FailureReflection
) -> str:
    """ä½¿ç”¨åæ€ç»“æœå¢å¼ºä»»åŠ¡æè¿°"""
    
    enhanced = f"""{original_goal}

[Context from Previous Attempt]
The hot start approach failed. Analysis:
- Issue: {reflection.root_cause}
- Recommendation: {reflection.specific_advice}

Please execute the task considering this context."""
    
    return enhanced

def _get_recent_ui_state(self, offset: int) -> Optional[Dict]:
    """è·å–å†å² UI çŠ¶æ€"""
    # éœ€è¦åœ¨æ‰§è¡Œè¿‡ç¨‹ä¸­ä¿å­˜ UI çŠ¶æ€åˆ° self.ui_history
    # æˆ–ä» trajectory ä¸­æå–
    pass
```

### **3.4 ä¿®æ”¹ _direct_execute_actions_async**

éœ€è¦è®°å½•å¤±è´¥çš„å…·ä½“æ­¥éª¤å’Œ UI çŠ¶æ€ï¼š

```python
async def _direct_execute_actions_async(self, ctx, actions):
    # ... ç°æœ‰é€»è¾‘
    
    for idx_action, action in enumerate(actions):
        # ä¿å­˜æ‰§è¡Œå‰çš„ UI çŠ¶æ€
        pre_ui = await self.tools_instance.get_state_async(include_screenshot=False)
        self._save_ui_snapshot(pre_ui, idx_action, "pre")
        
        # æ‰§è¡ŒåŠ¨ä½œ...
        
        if "Error" in result:
            # ä¿å­˜å¤±è´¥æ—¶çš„ UI çŠ¶æ€
            post_ui = await self.tools_instance.get_state_async(include_screenshot=False)
            self._save_ui_snapshot(post_ui, idx_action, "post")
            
            # è¿”å›æ—¶å¸¦ä¸Šå¤±è´¥æ­¥éª¤å·
            return False, f"Step {idx_action}: {result}", idx_action
    
    return True, "Success", -1

def _save_ui_snapshot(self, ui_state: Dict, step: int, phase: str):
    """ä¿å­˜ UI å¿«ç…§ä¾›åæ€ä½¿ç”¨"""
    if not hasattr(self, 'ui_snapshots'):
        self.ui_snapshots = {}
    self.ui_snapshots[f"step_{step}_{phase}"] = ui_state
```

### **3.5 é…ç½®æ–‡ä»¶æ”¯æŒ**

```yaml
# droidrun.yaml
agent:
  reflection:
    enabled: true
    trigger_on_hot_start_failure: true
    max_reflection_retries: 0  # æš‚ä¸æ”¯æŒåŸºäºåæ€çš„é‡è¯•
    reflection_confidence_threshold: 0.6
    save_failure_reflections: false  # Step 5 æ‰å®ç°
```

### **3.6 ç«¯åˆ°ç«¯æµ‹è¯•**

```python
# tests/test_hot_start_with_reflection.py

@pytest.mark.asyncio
async def test_hot_start_failure_with_reflection_e2e():
    """ç«¯åˆ°ç«¯æµ‹è¯•ï¼šçƒ­å¯åŠ¨å¤±è´¥ + åæ€ + å†·å¯åŠ¨"""
    
    # 1. å‡†å¤‡ï¼šä¸€ä¸ªä¼šå¯¼è‡´çƒ­å¯åŠ¨å¤±è´¥çš„åœºæ™¯
    agent = create_test_agent(reflection_enabled=True)
    
    # 2. æ¨¡æ‹Ÿçƒ­å¯åŠ¨å¤±è´¥
    result = await agent.execute_task(task_with_changed_ui)
    
    # 3. éªŒè¯åæ€è¢«è§¦å‘
    assert agent.failure_reflector.analyze_failure.called
    
    # 4. éªŒè¯å†·å¯åŠ¨ä»»åŠ¡æè¿°åŒ…å«åæ€å»ºè®®
    cold_start_task = extract_cold_start_task(result)
    assert "Issue:" in cold_start_task.description
    assert "Recommendation:" in cold_start_task.description
    
    # 5. éªŒè¯æœ€ç»ˆæˆåŠŸ
    assert result.success == True
```

### **è¾“å‡ºæˆæœ**
- âœ… çƒ­å¯åŠ¨å¤±è´¥æ—¶è‡ªåŠ¨è§¦å‘åæ€
- âœ… åæ€ç»“æœè®°å½•åˆ°æ—¥å¿—
- âœ… å†·å¯åŠ¨ä»»åŠ¡æè¿°åŒ…å«åæ€å»ºè®®
- âœ… é…ç½®é¡¹ç”Ÿæ•ˆ
- âœ… ç«¯åˆ°ç«¯æµ‹è¯•é€šè¿‡
- âœ… **å®é™…åœºæ™¯æµ‹è¯•**ï¼ˆæ‰‹åŠ¨è¿è¡Œä¸€ä¸ªä¼šå¤±è´¥çš„çƒ­å¯åŠ¨ä»»åŠ¡ï¼‰

---

## ğŸ¯ Step 4ï¼šä¼˜åŒ–å’Œæ‰©å±•ï¼ˆ1å¤©ï¼‰

### **ç›®æ ‡**
ä¼˜åŒ–æ€§èƒ½ï¼Œå¢åŠ å¯é€‰çš„å†·å¯åŠ¨é›†æˆï¼Œæå‡åæ€è´¨é‡ã€‚

### **4.1 æ€§èƒ½ä¼˜åŒ–**

```python
# 1. è½»é‡çº§ UI çŠ¶æ€ä¼ é€’
def _simplify_ui_state(self, ui_state: Dict, max_elements: int = 50) -> Dict:
    """ç®€åŒ– UI çŠ¶æ€ï¼Œå‡å°‘ token æ¶ˆè€—"""
    elements = ui_state.get('elements', [])
    
    # åªä¿ç•™å…³é”®ä¿¡æ¯
    simplified_elements = []
    for elem in elements[:max_elements]:
        simplified_elements.append({
            'index': elem.get('index'),
            'type': elem.get('class'),
            'text': elem.get('text', '')[:50],  # æˆªæ–­é•¿æ–‡æœ¬
            'clickable': elem.get('clickable'),
            'focused': elem.get('focused')
        })
    
    return {'elements': simplified_elements}

# 2. ç¼“å­˜åæ€ç»“æœï¼ˆç›¸åŒå¤±è´¥ä¸é‡å¤åæ€ï¼‰
def _get_failure_cache_key(self, context: FailureContext) -> str:
    """ç”Ÿæˆå¤±è´¥åœºæ™¯çš„ç¼“å­˜ key"""
    return f"{context.goal}_{context.failure_type}_{context.error_message}"

async def analyze_failure(self, context: FailureContext) -> FailureReflection:
    # æ£€æŸ¥ç¼“å­˜
    cache_key = self._get_failure_cache_key(context)
    if cache_key in self._reflection_cache:
        LoggingUtils.log_debug("FailureReflector", "Using cached reflection")
        return self._reflection_cache[cache_key]
    
    # æ‰§è¡Œåæ€...
    reflection = ...
    
    # ç¼“å­˜ç»“æœï¼ˆä¼šè¯çº§åˆ«ï¼‰
    self._reflection_cache[cache_key] = reflection
    return reflection
```

### **4.2 å†·å¯åŠ¨åŠ¨ä½œå¤±è´¥é›†æˆï¼ˆå¯é€‰ï¼‰**

```python
# droid_agent.py handle_codeact_execute æ–¹æ³•

async def handle_codeact_execute(
    self, ctx: Context, ev: CodeActResultEvent
) -> FinalizeEvent | ReflectionEvent | ReasoningLogicEvent:
    
    # ç°æœ‰é€»è¾‘...
    
    # âœ¨ æ–°å¢ï¼šå†·å¯åŠ¨å¤±è´¥æ—¶åæ€
    if not ev.success and self.failure_reflection_enabled:
        cold_start_reflection = await self._reflect_on_cold_start_failure(ev)
        if cold_start_reflection:
            # å°†åæ€ä¼ é€’ç»™ä¸‹ä¸€æ­¥ï¼ˆå¦‚æœæœ‰ reasoningï¼‰
            if self.reasoning:
                return ReasoningLogicEvent(
                    force_planning=True,
                    reflection=cold_start_reflection  # ä¼ é€’ç»™ PlannerAgent
                )
```

### **4.3 åæ€è´¨é‡æå‡**

```python
# 1. æ·»åŠ  few-shot ç¤ºä¾‹åˆ°æç¤ºè¯
REFLECTION_EXAMPLES = """
ç¤ºä¾‹ 1ï¼š
è¾“å…¥ï¼š
- å¤±è´¥åŠ¨ä½œ: tap_by_index(19)
- é”™è¯¯: Element not found
- UI å˜åŒ–: å…ƒç´ æ•°é‡ä» 45 å¢åŠ åˆ° 51

è¾“å‡ºï¼š
{
  "problem_type": "ui_changed",
  "root_cause": "ç›®æ ‡å…ƒç´ ç´¢å¼•ä»19å˜ä¸º25ï¼Œå› ä¸ºUIä¸­æ–°å¢äº†6ä¸ªå…ƒç´ ",
  "recommended_strategy": "fallback_cold_start",
  "specific_advice": "å»ºè®®ä½¿ç”¨æ–‡æœ¬åŒ¹é…å®šä½'å¼€å§‹æ—¥æœŸ'å­—æ®µï¼Œè€Œä¸æ˜¯ç´¢å¼•",
  "confidence": 0.9
}
"""

# 2. æ·»åŠ ç½®ä¿¡åº¦è®¡ç®—é€»è¾‘
def _calculate_confidence(
    self, 
    context: FailureContext,
    reflection: FailureReflection
) -> float:
    """æ ¹æ®å¤šä¸ªå› ç´ è®¡ç®—ç½®ä¿¡åº¦"""
    confidence = 0.5  # åŸºç¡€ç½®ä¿¡åº¦
    
    # UI å˜åŒ–æ˜ç¡® â†’ æé«˜ç½®ä¿¡åº¦
    if reflection.ui_changed and reflection.ui_change_summary:
        confidence += 0.2
    
    # é”™è¯¯ä¿¡æ¯æ˜ç¡® â†’ æé«˜ç½®ä¿¡åº¦
    if "not found" in context.error_message.lower():
        confidence += 0.15
    
    # æœ‰å…·ä½“çš„æ›¿ä»£å»ºè®® â†’ æé«˜ç½®ä¿¡åº¦
    if reflection.suggested_action:
        confidence += 0.15
    
    return min(confidence, 1.0)
```

### **4.4 é…ç½®é¡¹æ‰©å±•**

```yaml
agent:
  reflection:
    enabled: true
    
    # è§¦å‘é…ç½®
    trigger_on_hot_start_failure: true
    trigger_on_cold_start_failure: false  # å¯é€‰ï¼Œæˆæœ¬è¾ƒé«˜
    
    # æ€§èƒ½é…ç½®
    use_lightweight_context: true
    max_ui_elements_in_context: 50
    cache_reflections: true
    
    # è´¨é‡é…ç½®
    confidence_threshold: 0.6
    include_few_shot_examples: true
```

### **è¾“å‡ºæˆæœ**
- âœ… UI çŠ¶æ€ç®€åŒ–ï¼Œtoken æ¶ˆè€—é™ä½ 30%+
- âœ… åæ€ç»“æœç¼“å­˜æœºåˆ¶
- âœ… ï¼ˆå¯é€‰ï¼‰å†·å¯åŠ¨å¤±è´¥åæ€
- âœ… Few-shot ç¤ºä¾‹æå‡åæ€è´¨é‡
- âœ… ç½®ä¿¡åº¦è®¡ç®—æ›´å‡†ç¡®
- âœ… æ€§èƒ½æµ‹è¯•é€šè¿‡ï¼ˆåæ€æ—¶é—´ <5ç§’ï¼‰

---

## ğŸ’¾ Step 5ï¼šMemory ç³»ç»Ÿé›†æˆï¼ˆ1å¤©ï¼‰

### **ç›®æ ‡**
å°†å¤±è´¥åæ€ä¿å­˜åˆ° experienceï¼Œå½¢æˆé•¿æœŸçŸ¥è¯†ç§¯ç´¯ã€‚

### **5.1 æ‰©å±• Experience æ•°æ®ç»“æ„**

```python
# droidrun/agent/memory/experience.py

@dataclass
class Experience:
    # ç°æœ‰å­—æ®µ...
    
    # âœ¨ æ–°å¢å­—æ®µ
    failure_reflection: Optional[Dict] = None  # å¤±è´¥åæ€ç»“æœ
    
    def to_dict(self) -> Dict:
        data = {
            # ç°æœ‰åºåˆ—åŒ–...
        }
        
        if self.failure_reflection:
            data['failure_reflection'] = self.failure_reflection
        
        return data
    
    @classmethod
    def from_dict(cls, data: Dict):
        # ååºåˆ—åŒ–æ—¶åŒ…å« failure_reflection
        ...
```

### **5.2 ä¿å­˜å¤±è´¥åæ€åˆ° Memory**

```python
# droid_agent.py

async def execute_task(self, task: Task):
    # ... æ‰§è¡Œé€»è¾‘
    
    # ä»»åŠ¡ç»“æŸæ—¶ä¿å­˜ç»éªŒ
    if self.memory_enabled and self.trajectory:
        experience = Experience(
            goal=self.goal,
            success=final_result.success,
            trajectory=self.trajectory,
            # âœ¨ æ–°å¢ï¼šä¿å­˜åæ€ç»“æœ
            failure_reflection=self._get_failure_reflection_summary() if not final_result.success else None
        )
        
        await self.memory_manager.save_experience(experience)

def _get_failure_reflection_summary(self) -> Optional[Dict]:
    """è·å–æœ¬æ¬¡æ‰§è¡Œçš„å¤±è´¥åæ€æ±‡æ€»"""
    if not hasattr(self, '_failure_reflections'):
        return None
    
    # æ±‡æ€»æ‰€æœ‰åæ€ç»“æœ
    summary = {
        'reflections': [r.to_dict() for r in self._failure_reflections],
        'main_issue': self._failure_reflections[-1].problem_type if self._failure_reflections else None,
        'lessons_learned': [r.specific_advice for r in self._failure_reflections]
    }
    
    return summary
```

### **5.3 æ£€ç´¢å†å²å¤±è´¥ç»éªŒ**

```python
# droid_agent.py execute_task

async def execute_task(self, task: Task):
    # æ£€ç´¢ç›¸ä¼¼ç»éªŒæ—¶ï¼Œä¹Ÿæ£€ç´¢å¤±è´¥ç»éªŒ
    if self.memory_enabled:
        similar_experiences = await self.memory_manager.retrieve_similar(
            goal=self.goal,
            include_failures=True  # âœ¨ æ–°å¢å‚æ•°
        )
        
        # æå–å¤±è´¥æ•™è®­
        failure_lessons = self._extract_failure_lessons(similar_experiences)
        
        if failure_lessons:
            LoggingUtils.log_info("DroidAgent", "ğŸ“š Found {count} lessons from past failures", 
                                count=len(failure_lessons))
            
            # å¢å¼º Persona æˆ–ä»»åŠ¡æè¿°
            self._enhance_execution_with_lessons(failure_lessons)

def _extract_failure_lessons(self, experiences: List[Experience]) -> List[str]:
    """ä»å†å²ç»éªŒä¸­æå–å¤±è´¥æ•™è®­"""
    lessons = []
    
    for exp in experiences:
        if not exp.success and exp.failure_reflection:
            reflection_data = exp.failure_reflection
            if 'lessons_learned' in reflection_data:
                lessons.extend(reflection_data['lessons_learned'])
    
    return lessons

def _enhance_execution_with_lessons(self, lessons: List[str]):
    """ä½¿ç”¨å†å²æ•™è®­å¢å¼ºæ‰§è¡Œ"""
    # æ–¹å¼ 1ï¼šæ·»åŠ åˆ° Persona
    lesson_text = "\n".join([f"- {lesson}" for lesson in lessons[:3]])  # æœ€å¤š 3 æ¡
    
    enhanced_persona_content = f"""
{self.persona.content}

[Important Lessons from Past Failures]
{lesson_text}

Please avoid these mistakes when executing the task.
"""
    # ä¸´æ—¶ä¿®æ”¹ persona
    self.persona.content = enhanced_persona_content
```

### **5.4 é…ç½®æ”¯æŒ**

```yaml
agent:
  reflection:
    enabled: true
    save_failure_reflections: true
    use_historical_failures: true
    max_lessons_to_apply: 3
```

### **è¾“å‡ºæˆæœ**
- âœ… å¤±è´¥åæ€ä¿å­˜åˆ° experience JSON
- âœ… æ£€ç´¢å†å²å¤±è´¥ç»éªŒ
- âœ… å†å²æ•™è®­åº”ç”¨åˆ°æ–°ä»»åŠ¡
- âœ… ç›¸åŒé”™è¯¯é‡å¤ç‡æ˜¾è‘—é™ä½
- âœ… æ•°æ®åºåˆ—åŒ–/ååºåˆ—åŒ–æµ‹è¯•é€šè¿‡

---

## ğŸ“Š Step 6ï¼šæµ‹è¯•ã€ä¼˜åŒ–å’Œæ–‡æ¡£ï¼ˆ1å¤©ï¼‰

### **ç›®æ ‡**
å…¨é¢æµ‹è¯•ï¼Œæ€§èƒ½è°ƒä¼˜ï¼Œå®Œå–„æ–‡æ¡£ã€‚

### **6.1 å…¨é¢æµ‹è¯•**

```python
# 1. å•å…ƒæµ‹è¯•è¡¥å…¨
# tests/test_failure_reflector_unit.py
- test_ui_change_detection()
- test_confidence_calculation()
- test_llm_response_parsing_error_handling()
- test_fallback_reflection()

# 2. é›†æˆæµ‹è¯•
# tests/test_reflection_integration.py
- test_hot_start_failure_with_reflection()
- test_cold_start_with_historical_lessons()
- test_memory_integration()

# 3. æ€§èƒ½æµ‹è¯•
# tests/test_reflection_performance.py
- test_reflection_latency()  # åº” <5ç§’
- test_token_consumption()   # åº” <1500 tokens/æ¬¡
- test_cache_effectiveness()

# 4. çœŸå®åœºæ™¯æµ‹è¯•
# æ‰‹åŠ¨æµ‹è¯• 3-5 ä¸ªçœŸå®å¤±è´¥åœºæ™¯
- æ—¥æœŸé€‰æ‹©å™¨ç´¢å¼•å˜åŒ–
- è¡¨å•å­—æ®µå¢åˆ 
- ç½‘ç»œè¶…æ—¶
- æƒé™æ‹’ç»
```

### **6.2 æ€§èƒ½è°ƒä¼˜**

```python
# 1. è°ƒæ•´æç¤ºè¯é•¿åº¦
# - ç§»é™¤å†—ä½™æè¿°
# - å‹ç¼©ç¤ºä¾‹

# 2. ä¼˜åŒ– UI çŠ¶æ€ä¼ é€’
# - åªä¼ é€’å¯äº¤äº’å…ƒç´ 
# - ç§»é™¤é‡å¤ä¿¡æ¯

# 3. å¹¶å‘ä¼˜åŒ–
# - UI å¯¹æ¯”å’Œ LLM è°ƒç”¨å¹¶å‘æ‰§è¡Œ

# 4. è¶…æ—¶æ§åˆ¶
async def analyze_failure(self, context, timeout=30):
    try:
        return await asyncio.wait_for(
            self._do_analyze(context),
            timeout=timeout
        )
    except asyncio.TimeoutError:
        return self._create_fallback_reflection(context)
```

### **6.3 æ—¥å¿—å’Œç›‘æ§**

```python
# æ·»åŠ è¯¦ç»†çš„åæ€æŒ‡æ ‡æ—¥å¿—
class ReflectionMetrics:
    def __init__(self):
        self.total_reflections = 0
        self.successful_reflections = 0
        self.avg_latency = 0.0
        self.avg_confidence = 0.0
    
    def log_summary(self):
        LoggingUtils.log_info(
            "ReflectionMetrics",
            "Total: {total}, Success: {success}, Avg Latency: {latency:.2f}s, Avg Confidence: {conf:.2f}",
            total=self.total_reflections,
            success=self.successful_reflections,
            latency=self.avg_latency,
            conf=self.avg_confidence
        )
```

### **6.4 æ–‡æ¡£å®Œå–„**

åˆ›å»ºä»¥ä¸‹æ–‡æ¡£ï¼š

1. **ä½¿ç”¨æ–‡æ¡£**ï¼ˆ`docs/failure_reflection_usage.md`ï¼‰
   - å¦‚ä½•å¯ç”¨åæ€
   - é…ç½®é¡¹è¯´æ˜
   - é¢„æœŸæ•ˆæœ
   - æ•…éšœæ’æŸ¥

2. **å¼€å‘æ–‡æ¡£**ï¼ˆ`docs/failure_reflection_dev.md`ï¼‰
   - æ¶æ„è®¾è®¡
   - æ•°æ®æµå›¾
   - æ‰©å±•æŒ‡å—
   - API å‚è€ƒ

3. **å˜æ›´æ—¥å¿—**ï¼ˆ`CHANGELOG.md`ï¼‰
   ```markdown
   ## [v2.1.0] - 2025-12-03
   
   ### Added
   - âœ¨ å¤±è´¥åˆ†æå‹åæ€æ¨¡å—
   - çƒ­å¯åŠ¨å¤±è´¥æ—¶è‡ªåŠ¨åˆ†æåŸå› 
   - åŸºäºåæ€çš„æ™ºèƒ½å›é€€ç­–ç•¥
   - å¤±è´¥ç»éªŒé•¿æœŸè®°å¿†
   
   ### Configuration
   - `agent.reflection.enabled`
   - `agent.reflection.trigger_on_hot_start_failure`
   - `agent.reflection.save_failure_reflections`
   ```

### **6.5 ä»£ç å®¡æŸ¥æ¸…å•**

- [ ] æ‰€æœ‰å…¬å…±æ–¹æ³•æœ‰æ–‡æ¡£å­—ç¬¦ä¸²
- [ ] å¼‚å¸¸å¤„ç†å®Œå–„
- [ ] æ—¥å¿—çº§åˆ«åˆç†
- [ ] æ²¡æœ‰ç¡¬ç¼–ç å€¼
- [ ] æµ‹è¯•è¦†ç›–ç‡ >=80%
- [ ] æ€§èƒ½æŒ‡æ ‡è¾¾æ ‡
- [ ] å‘åå…¼å®¹ï¼ˆreflection.enabled=false æ—¶ä¸å½±å“ç°æœ‰åŠŸèƒ½ï¼‰

### **è¾“å‡ºæˆæœ**
- âœ… æ‰€æœ‰æµ‹è¯•é€šè¿‡ï¼ˆå•å…ƒ+é›†æˆ+æ€§èƒ½ï¼‰
- âœ… çœŸå®åœºæ™¯éªŒè¯ï¼ˆæˆåŠŸç‡æå‡è¯æ®ï¼‰
- âœ… æ€§èƒ½æŒ‡æ ‡è¾¾æ ‡
- âœ… æ–‡æ¡£å®Œå–„
- âœ… ä»£ç å®¡æŸ¥é€šè¿‡
- âœ… **å‡†å¤‡å¥½åˆå¹¶åˆ°ä¸»åˆ†æ”¯**

---

## ğŸ“ˆ éªŒæ”¶æ ‡å‡†

### **åŠŸèƒ½éªŒæ”¶**
- [ ] çƒ­å¯åŠ¨å¤±è´¥æ—¶è‡ªåŠ¨è§¦å‘åæ€ï¼ˆ100% è§¦å‘ç‡ï¼‰
- [ ] åæ€ç»“æœåŒ…å«é—®é¢˜ç±»å‹ã€æ ¹å› ã€å»ºè®®ï¼ˆ100% å®Œæ•´æ€§ï¼‰
- [ ] å†·å¯åŠ¨ä»»åŠ¡æè¿°åŒ…å«åæ€å»ºè®®ï¼ˆç½®ä¿¡åº¦ >0.6 æ—¶ï¼‰
- [ ] å¤±è´¥åæ€ä¿å­˜åˆ° experienceï¼ˆå¯é…ç½®ï¼‰
- [ ] å†å²å¤±è´¥æ•™è®­åº”ç”¨åˆ°æ–°ä»»åŠ¡

### **æ€§èƒ½éªŒæ”¶**
- [ ] å•æ¬¡åæ€æ—¶é—´ <5 ç§’ï¼ˆP95ï¼‰
- [ ] Token æ¶ˆè€— <1500 tokens/æ¬¡
- [ ] å¯¹ç°æœ‰æµç¨‹å½±å“ <10%ï¼ˆæ— åæ€æ—¶ï¼‰
- [ ] ç¼“å­˜å‘½ä¸­ç‡ >30%ï¼ˆé‡å¤å¤±è´¥åœºæ™¯ï¼‰

### **è´¨é‡éªŒæ”¶**
- [ ] æµ‹è¯•è¦†ç›–ç‡ >=80%
- [ ] æ—  P0/P1 bug
- [ ] ä»£ç å®¡æŸ¥é€šè¿‡
- [ ] æ–‡æ¡£å®Œæ•´

### **ä¸šåŠ¡éªŒæ”¶**
- [ ] çƒ­å¯åŠ¨å¤±è´¥åå†·å¯åŠ¨æˆåŠŸç‡æå‡ >10%
- [ ] ç›¸åŒé”™è¯¯é‡å¤ç‡é™ä½ >50%
- [ ] ç”¨æˆ·å¯é…ç½®å¼€å…³ï¼Œä¸å¼ºåˆ¶å¯ç”¨

---

## ğŸ¯ æ€»ç»“

| æ­¥éª¤   | æ—¶é—´  | å…³é”®äº§å‡º               | ä¾èµ–     |
| ------ | ----- | ---------------------- | -------- |
| Step 0 | 0.5å¤© | ç¯å¢ƒå‡†å¤‡ã€ä»£ç ç†è§£     | -        |
| Step 1 | 1å¤©   | æ•°æ®ç»“æ„ã€åæ€å™¨æ¡†æ¶   | Step 0   |
| Step 2 | 1.5å¤© | LLM è°ƒç”¨ã€UI åˆ†æ      | Step 1   |
| Step 3 | 1å¤©   | çƒ­å¯åŠ¨é›†æˆã€ç«¯åˆ°ç«¯æµ‹è¯• | Step 2   |
| Step 4 | 1å¤©   | æ€§èƒ½ä¼˜åŒ–ã€è´¨é‡æå‡     | Step 3   |
| Step 5 | 1å¤©   | Memory é›†æˆã€é•¿æœŸè®°å¿†  | Step 4   |
| Step 6 | 1å¤©   | å…¨é¢æµ‹è¯•ã€æ–‡æ¡£å®Œå–„     | Step 1-5 |

**æ€»è®¡ï¼š7 å¤©ï¼ˆçº¦ 1.5 å‘¨ï¼‰**

### **é‡Œç¨‹ç¢‘**
- **M1ï¼ˆ3å¤©åï¼‰**ï¼šæ ¸å¿ƒåæ€åŠŸèƒ½å®Œæˆï¼ˆStep 1-2ï¼‰
- **M2ï¼ˆ5å¤©åï¼‰**ï¼šçƒ­å¯åŠ¨é›†æˆå®Œæˆï¼ˆStep 3-4ï¼‰
- **M3ï¼ˆ7å¤©åï¼‰**ï¼šå®Œæ•´åŠŸèƒ½ä¸Šçº¿ï¼ˆStep 5-6ï¼‰

è¿™ä¸ªè®¡åˆ’ä¿è¯äº†**æ¸è¿›å¼å®æ–½ã€ç‹¬ç«‹æµ‹è¯•ã€é£é™©å¯æ§**ã€‚æ¯ä¸ªæ­¥éª¤éƒ½æœ‰æ˜ç¡®çš„è¾“å‡ºæˆæœå’ŒéªŒæ”¶æ ‡å‡†ã€‚ğŸ¯