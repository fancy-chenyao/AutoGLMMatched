# ğŸ¯ äº¤äº’å¼æ‰§è¡Œå®Œæ•´å®æ–½æ–¹æ¡ˆ

## ğŸ“‹ ç›®å½•

```
1. æ€»ä½“æ¶æ„
2. å®æ–½æ­¥éª¤æ‹†è§£ï¼ˆ5ä¸ªPhaseï¼‰
3. æ¯ä¸ªæ­¥éª¤çš„è¯¦ç»†å®ç°
4. é›†æˆæµ‹è¯•æ–¹æ¡ˆ
5. éªŒæ”¶æ ‡å‡†
6. é£é™©æ§åˆ¶
```

---

## 1. æ€»ä½“æ¶æ„

### 1.1 æ ¸å¿ƒç»„ä»¶

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Phase 1: åŸºç¡€æ•°æ®ç»“æ„                          â”‚
â”‚  â”œâ”€ ResumeContext (æ¢å¤ä¸Šä¸‹æ–‡)                 â”‚
â”‚  â”œâ”€ TaskExecutionContext (ä»»åŠ¡ä¸Šä¸‹æ–‡)          â”‚
â”‚  â””â”€ æµ‹è¯•ï¼šå•å…ƒæµ‹è¯•                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
              â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Phase 2: äº¤äº’ç®¡ç†å™¨                            â”‚
â”‚  â”œâ”€ InteractionManager (éé˜»å¡è¯¢é—®)            â”‚
â”‚  â”œâ”€ TimeoutManager (è¶…æ—¶ç®¡ç†)                  â”‚
â”‚  â””â”€ æµ‹è¯•ï¼šMockæµ‹è¯• + é›†æˆæµ‹è¯•                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
              â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Phase 3: ask_userå·¥å…·                          â”‚
â”‚  â”œâ”€ WebSocketTools.ask_user() (LLMå¯è°ƒç”¨)      â”‚
â”‚  â”œâ”€ System Promptå¢å¼º (å‘Šè¯‰LLMå¦‚ä½•ä½¿ç”¨)        â”‚
â”‚  â””â”€ æµ‹è¯•ï¼šç«¯åˆ°ç«¯æµ‹è¯•                            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
              â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Phase 4: DroidAgenté›†æˆ                        â”‚
â”‚  â”œâ”€ ä»»åŠ¡ç”Ÿå‘½å‘¨æœŸç®¡ç†                            â”‚
â”‚  â”œâ”€ è½»é‡çº§æ£€æµ‹å™¨                                â”‚
â”‚  â””â”€ æµ‹è¯•ï¼šå®Œæ•´æµç¨‹æµ‹è¯•                          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
              â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Phase 5: Androidç«¯ + ä¼˜åŒ–                      â”‚
â”‚  â”œâ”€ å¯¹è¯æ¡†å·¥å‚                                  â”‚
â”‚  â”œâ”€ æ¶ˆæ¯å¤„ç†                                    â”‚
â”‚  â””â”€ æµ‹è¯•ï¼šçœŸæœºæµ‹è¯• + å‹åŠ›æµ‹è¯•                   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## 2. å®æ–½æ­¥éª¤æ‹†è§£

### Phase 1: åŸºç¡€æ•°æ®ç»“æ„ï¼ˆ2å¤©ï¼‰

**ç›®æ ‡**ï¼šå®ç°æ ¸å¿ƒæ•°æ®ç»“æ„ï¼Œç¡®ä¿çŠ¶æ€ç®¡ç†å¯é 

**è¾“å‡º**ï¼š
- `resume_context.py`
- `task_context.py`
- `task_state.py`

### Phase 2: äº¤äº’ç®¡ç†å™¨ï¼ˆ2-3å¤©ï¼‰

**ç›®æ ‡**ï¼šå®ç°éé˜»å¡è¯¢é—®æœºåˆ¶

**è¾“å‡º**ï¼š
- `manager.py`
- `timeout_manager.py`
- `message_protocol.py`ï¼ˆæ¶ˆæ¯å®šä¹‰ï¼‰

### Phase 3: ask_userå·¥å…·ï¼ˆ2å¤©ï¼‰

**ç›®æ ‡**ï¼šè®©LLMå¯ä»¥è°ƒç”¨è¯¢é—®å·¥å…·

**è¾“å‡º**ï¼š
- `WebSocketTools.ask_user()`
- å¢å¼ºçš„System Prompt
- å·¥å…·æ³¨å†Œ

### Phase 4: DroidAgenté›†æˆï¼ˆ2å¤©ï¼‰

**ç›®æ ‡**ï¼šæ•´åˆæ‰€æœ‰ç»„ä»¶åˆ°æ‰§è¡Œæµç¨‹

**è¾“å‡º**ï¼š
- [DroidAgent](cci:2://file:///e:/WorkRelated/ResumeScreeningRelated/GUI/droidrun/droidrun/agent/droid/droid_agent.py:86:0-2235:22)æ”¹é€ 
- `TaskLifecycleManager`
- `LightweightDetector`

### Phase 5: Androidç«¯ + ä¼˜åŒ–ï¼ˆ2-3å¤©ï¼‰

**ç›®æ ‡**ï¼šå®Œå–„ç”¨æˆ·äº¤äº’ä½“éªŒ

**è¾“å‡º**ï¼š
- `DialogFactory.kt`
- `MessageHandler.kt`
- æ€§èƒ½ä¼˜åŒ–

---

## 3. è¯¦ç»†å®æ–½æ–¹æ¡ˆ

---

## Phase 1: åŸºç¡€æ•°æ®ç»“æ„ï¼ˆDay 1-2ï¼‰

### 3.1.1 å®ç°å†…å®¹

#### æ–‡ä»¶1: `droidrun/agent/interaction/task_state.py`

```python
"""ä»»åŠ¡çŠ¶æ€å®šä¹‰"""

from enum import Enum

class TaskState(Enum):
    """ä»»åŠ¡çŠ¶æ€æšä¸¾"""
    INITIALIZED = "initialized"
    RUNNING = "running"
    WAITING_USER = "waiting_user"
    COMPLETED = "completed"
    FAILED = "failed"
    CANCELLED = "cancelled"

class ResumeStrategy(Enum):
    """æ¢å¤ç­–ç•¥"""
    REPLACE_PARAM = "replace_param"
    ELEMENT_SELECTION = "element_select"
    CONFIRM_CANCEL = "confirm_cancel"
    PARAMETER_FILL = "parameter_fill"
```

#### æ–‡ä»¶2: `droidrun/agent/interaction/resume_context.py`

```python
"""æ¢å¤ä¸Šä¸‹æ–‡"""

from dataclasses import dataclass, field
from typing import Callable, Any, Dict, Optional, List
import time
import re
import asyncio

from .task_state import ResumeStrategy

@dataclass
class ResumeContext:
    """å®Œæ•´çš„æ¢å¤ä¸Šä¸‹æ–‡"""
    
    resume_id: str
    step_index: int
    action_name: str
    action_func: Callable
    original_args: tuple = field(default_factory=tuple)
    original_kwargs: Dict[str, Any] = field(default_factory=dict)
    strategy: ResumeStrategy = ResumeStrategy.REPLACE_PARAM
    created_at: float = field(default_factory=lambda: time.time())
    context_data: Dict[str, Any] = field(default_factory=dict)
    
    modified_args: Optional[tuple] = None
    modified_kwargs: Optional[Dict[str, Any]] = None
    
    def apply_answer(
        self, 
        answer: Any,
        additional_data: Dict[str, Any] = None
    ) -> tuple:
        """åº”ç”¨ç”¨æˆ·å›ç­”"""
        args = list(self.original_args)
        kwargs = self.original_kwargs.copy()
        
        if self.strategy == ResumeStrategy.REPLACE_PARAM:
            if "text" in kwargs:
                kwargs["text"] = answer
            elif len(args) > 0:
                args[0] = answer
        
        elif self.strategy == ResumeStrategy.CONFIRM_CANCEL:
            confirmed = self._parse_confirmation(answer)
            kwargs["__user_confirmed"] = confirmed
        
        elif self.strategy == ResumeStrategy.PARAMETER_FILL:
            param_name = self.context_data.get("param_name")
            if param_name:
                kwargs[param_name] = answer
        
        self.modified_args = tuple(args)
        self.modified_kwargs = kwargs
        
        return (self.modified_args, self.modified_kwargs)
    
    def _parse_confirmation(self, answer: Any) -> bool:
        """è§£æç¡®è®¤/å–æ¶ˆ"""
        if isinstance(answer, bool):
            return answer
        answer_str = str(answer).lower()
        positive = ["æ˜¯", "yes", "y", "ç¡®å®š", "ç¡®è®¤", "ok", "true", "1"]
        return any(w in answer_str for w in positive)
    
    async def execute_with_modified_params(self) -> Any:
        """ä½¿ç”¨ä¿®æ”¹åçš„å‚æ•°æ‰§è¡ŒåŠ¨ä½œ"""
        if self.modified_args is None:
            raise ValueError("Must call apply_answer() first")
        
        if self.strategy == ResumeStrategy.CONFIRM_CANCEL:
            if not self.modified_kwargs.get("__user_confirmed", False):
                raise UserCancelledError("User cancelled")
        
        if asyncio.iscoroutinefunction(self.action_func):
            return await self.action_func(
                *self.modified_args, 
                **self.modified_kwargs
            )
        else:
            return self.action_func(
                *self.modified_args, 
                **self.modified_kwargs
            )

class UserCancelledError(Exception):
    """ç”¨æˆ·å–æ¶ˆæ“ä½œ"""
    pass
```

#### æ–‡ä»¶3: `droidrun/agent/interaction/task_context.py`

```python
"""ä»»åŠ¡æ‰§è¡Œä¸Šä¸‹æ–‡"""

from typing import Dict, Any, List, Callable, Optional
import time

from .task_state import TaskState
from .resume_context import ResumeContext

class TaskExecutionContext:
    """ä»»åŠ¡æ‰§è¡Œä¸Šä¸‹æ–‡"""
    
    def __init__(self, task_id: str, goal: str, task_type: str = None):
        self.task_id = task_id
        self.goal = goal
        self.task_type = task_type
        
        self.state = TaskState.INITIALIZED
        self.created_at = time.time()
        self.updated_at = time.time()
        
        self.current_step = 0
        self.executed_actions = []
        self.variables: Dict[str, Any] = {}
        
        self.current_resume_context: Optional[ResumeContext] = None
        self.pending_question_id: Optional[str] = None
        self.resume_callback: Optional[Callable] = None
        
        self.result = None
        self.error = None
    
    def set_state(self, new_state: TaskState, reason: str = None):
        """æ›´æ–°çŠ¶æ€"""
        self.state = new_state
        self.updated_at = time.time()
        print(f"[TaskContext] State: {new_state.value} (reason: {reason})")
    
    def pause_for_user_input(
        self,
        question_id: str,
        resume_context: ResumeContext,
        resume_callback: Callable,
        reason: str = None
    ):
        """æš‚åœä»»åŠ¡"""
        self.current_resume_context = resume_context
        self.pending_question_id = question_id
        self.resume_callback = resume_callback
        
        self.set_state(TaskState.WAITING_USER, reason)
        print(f"[TaskContext] â¸ï¸ Task paused: {question_id}")
    
    def resume_with_answer(self, answer: Any, additional_data: Dict = None):
        """æ¢å¤ä»»åŠ¡"""
        if self.state != TaskState.WAITING_USER:
            raise ValueError(f"Cannot resume in state: {self.state}")
        
        if not self.current_resume_context:
            raise ValueError("No resume context")
        
        self.current_resume_context.apply_answer(answer, additional_data)
        self.set_state(TaskState.RUNNING)
        
        print(f"[TaskContext] â–¶ï¸ Task resumed with: {str(answer)[:50]}")
        
        if self.resume_callback:
            self.resume_callback(self.current_resume_context, answer)
    
    def complete(self, result: Any):
        """æ ‡è®°å®Œæˆ"""
        self.set_state(TaskState.COMPLETED)
        self.result = result
    
    def fail(self, error: str):
        """æ ‡è®°å¤±è´¥"""
        self.set_state(TaskState.FAILED)
        self.error = error
```

### 3.1.2 å•å…ƒæµ‹è¯•

#### æ–‡ä»¶: `tests/agent/interaction/test_resume_context.py`

```python
"""æµ‹è¯•ResumeContext"""

import pytest
import asyncio
from droidrun.agent.interaction.resume_context import (
    ResumeContext, 
    ResumeStrategy,
    UserCancelledError
)

def test_resume_context_creation():
    """æµ‹è¯•åˆ›å»ºResumeContext"""
    ctx = ResumeContext(
        resume_id="test-1",
        step_index=0,
        action_name="tap_by_index",
        action_func=lambda idx: f"tapped {idx}",
        original_args=(10,),
        original_kwargs={"comment": "test"},
        strategy=ResumeStrategy.REPLACE_PARAM
    )
    
    assert ctx.resume_id == "test-1"
    assert ctx.step_index == 0
    assert ctx.action_name == "tap_by_index"

def test_apply_answer_replace_param():
    """æµ‹è¯•åº”ç”¨å›ç­”-æ›¿æ¢å‚æ•°"""
    ctx = ResumeContext(
        resume_id="test-2",
        step_index=0,
        action_name="input_text",
        action_func=lambda text: text,
        original_args=(),
        original_kwargs={"text": "old_value"},
        strategy=ResumeStrategy.REPLACE_PARAM
    )
    
    args, kwargs = ctx.apply_answer("new_value")
    
    assert kwargs["text"] == "new_value"

def test_apply_answer_confirm():
    """æµ‹è¯•åº”ç”¨å›ç­”-ç¡®è®¤"""
    ctx = ResumeContext(
        resume_id="test-3",
        step_index=0,
        action_name="tap_by_index",
        action_func=lambda idx: idx,
        original_args=(10,),
        strategy=ResumeStrategy.CONFIRM_CANCEL
    )
    
    # ç¡®è®¤
    args, kwargs = ctx.apply_answer("æ˜¯")
    assert kwargs["__user_confirmed"] == True
    
    # å–æ¶ˆ
    args, kwargs = ctx.apply_answer("å¦")
    assert kwargs["__user_confirmed"] == False

@pytest.mark.asyncio
async def test_execute_with_confirmation():
    """æµ‹è¯•æ‰§è¡Œ-éœ€è¦ç¡®è®¤"""
    executed = False
    
    def action_func(idx, **kwargs):
        nonlocal executed
        if not kwargs.get("__user_confirmed"):
            raise Exception("Not confirmed")
        executed = True
        return "success"
    
    ctx = ResumeContext(
        resume_id="test-4",
        step_index=0,
        action_name="tap_by_index",
        action_func=action_func,
        original_args=(10,),
        strategy=ResumeStrategy.CONFIRM_CANCEL
    )
    
    # ç”¨æˆ·å–æ¶ˆ
    ctx.apply_answer("å¦")
    with pytest.raises(UserCancelledError):
        await ctx.execute_with_modified_params()
    
    assert not executed
    
    # ç”¨æˆ·ç¡®è®¤
    ctx.apply_answer("æ˜¯")
    result = await ctx.execute_with_modified_params()
    
    assert executed
    assert result == "success"
```

#### æ–‡ä»¶: `tests/agent/interaction/test_task_context.py`

```python
"""æµ‹è¯•TaskExecutionContext"""

import pytest
from droidrun.agent.interaction.task_context import TaskExecutionContext
from droidrun.agent.interaction.task_state import TaskState
from droidrun.agent.interaction.resume_context import ResumeContext, ResumeStrategy

def test_task_context_creation():
    """æµ‹è¯•åˆ›å»ºTaskContext"""
    ctx = TaskExecutionContext(
        task_id="task-1",
        goal="æµ‹è¯•ä»»åŠ¡",
        task_type="test"
    )
    
    assert ctx.task_id == "task-1"
    assert ctx.goal == "æµ‹è¯•ä»»åŠ¡"
    assert ctx.state == TaskState.INITIALIZED

def test_pause_and_resume():
    """æµ‹è¯•æš‚åœå’Œæ¢å¤"""
    ctx = TaskExecutionContext("task-2", "æµ‹è¯•")
    
    resumed = False
    resume_value = None
    
    def callback(resume_ctx, answer):
        nonlocal resumed, resume_value
        resumed = True
        resume_value = answer
    
    resume_ctx = ResumeContext(
        resume_id="r-1",
        step_index=0,
        action_name="test",
        action_func=lambda: None,
        strategy=ResumeStrategy.PARAMETER_FILL
    )
    
    # æš‚åœ
    ctx.pause_for_user_input("q-1", resume_ctx, callback, "test pause")
    
    assert ctx.state == TaskState.WAITING_USER
    assert ctx.pending_question_id == "q-1"
    
    # æ¢å¤
    ctx.resume_with_answer("test answer")
    
    assert ctx.state == TaskState.RUNNING
    assert resumed
    assert resume_value == "test answer"

def test_state_transitions():
    """æµ‹è¯•çŠ¶æ€è½¬æ¢"""
    ctx = TaskExecutionContext("task-3", "æµ‹è¯•")
    
    # INITIALIZED -> RUNNING
    ctx.set_state(TaskState.RUNNING)
    assert ctx.state == TaskState.RUNNING
    
    # RUNNING -> COMPLETED
    ctx.complete("success")
    assert ctx.state == TaskState.COMPLETED
    assert ctx.result == "success"
    
    # æµ‹è¯•å¤±è´¥çŠ¶æ€
    ctx2 = TaskExecutionContext("task-4", "æµ‹è¯•")
    ctx2.fail("error message")
    assert ctx2.state == TaskState.FAILED
    assert ctx2.error == "error message"
```

### 3.1.3 Phase 1 éªŒæ”¶æ ‡å‡†

- [ ] æ‰€æœ‰å•å…ƒæµ‹è¯•é€šè¿‡ï¼ˆè¦†ç›–ç‡ > 90%ï¼‰
- [ ] `ResumeContext`èƒ½æ­£ç¡®åº”ç”¨ç”¨æˆ·å›ç­”
- [ ] `TaskExecutionContext`çŠ¶æ€è½¬æ¢æ­£ç¡®
- [ ] æš‚åœ/æ¢å¤æœºåˆ¶å·¥ä½œæ­£å¸¸

---

## Phase 2: äº¤äº’ç®¡ç†å™¨ï¼ˆDay 3-5ï¼‰

### 3.2.1 å®ç°å†…å®¹

#### æ–‡ä»¶1: `droidrun/agent/interaction/timeout_manager.py`

```python
"""è¶…æ—¶ç®¡ç†å™¨"""

import asyncio
from typing import Dict, Callable

class TimeoutManager:
    """ç»Ÿä¸€è¶…æ—¶ç®¡ç†"""
    
    def __init__(self):
        self._timers: Dict[str, asyncio.Task] = {}
    
    def set_timeout(
        self,
        identifier: str,
        timeout_seconds: int,
        callback: Callable
    ):
        """è®¾ç½®è¶…æ—¶"""
        async def timeout_task():
            try:
                await asyncio.sleep(timeout_seconds)
                callback()
            except asyncio.CancelledError:
                pass
            except Exception as e:
                print(f"[TimeoutManager] Error: {e}")
        
        task = asyncio.create_task(timeout_task())
        self._timers[identifier] = task
        print(f"[TimeoutManager] â²ï¸ Set timeout: {identifier}, {timeout_seconds}s")
    
    def cancel_timeout(self, identifier: str) -> bool:
        """å–æ¶ˆè¶…æ—¶"""
        task = self._timers.pop(identifier, None)
        if task and not task.done():
            task.cancel()
            print(f"[TimeoutManager] â¹ï¸ Cancelled: {identifier}")
            return True
        return False
    
    def cancel_all(self):
        """å–æ¶ˆæ‰€æœ‰è¶…æ—¶"""
        for task in list(self._timers.values()):
            if not task.done():
                task.cancel()
        self._timers.clear()
```

#### æ–‡ä»¶2: `droidrun/agent/interaction/manager.py`

```python
"""äº¤äº’ç®¡ç†å™¨"""

from typing import Dict, Callable, Any, List, Optional
import asyncio
import time
import uuid

from .task_context import TaskExecutionContext
from .timeout_manager import TimeoutManager

class PendingInteraction:
    """å¾…å¤„ç†çš„äº¤äº’"""
    def __init__(
        self,
        question_id: str,
        task_context: TaskExecutionContext,
        callback: Callable,
        default: Any = None
    ):
        self.question_id = question_id
        self.task_context = task_context
        self.callback = callback
        self.default = default
        self.created_at = time.time()

class InteractionManager:
    """äº¤äº’ç®¡ç†å™¨ï¼ˆéé˜»å¡ï¼‰"""
    
    def __init__(self, tools_instance=None):
        self.tools = tools_instance
        self._pending_interactions: Dict[str, PendingInteraction] = {}
        self.timeout_manager = TimeoutManager()
        self._current_task_context: Optional[TaskExecutionContext] = None
        
        self.stats = {
            "total_asked": 0,
            "total_answered": 0,
            "total_timeout": 0,
            "total_cancelled": 0
        }
    
    def set_current_task_context(self, context: TaskExecutionContext):
        """è®¾ç½®å½“å‰ä»»åŠ¡ä¸Šä¸‹æ–‡"""
        self._current_task_context = context
    
    def get_current_task_context(self) -> Optional[TaskExecutionContext]:
        """è·å–å½“å‰ä»»åŠ¡ä¸Šä¸‹æ–‡"""
        return self._current_task_context
    
    def ask_user_async(
        self,
        task_context: TaskExecutionContext,
        question: str,
        question_type: str = "text",
        options: List[str] = None,
        default: Any = None,
        timeout: int = 60,
        on_answer: Callable = None
    ) -> str:
        """éé˜»å¡è¯¢é—®ç”¨æˆ·"""
        question_id = str(uuid.uuid4())
        
        # æ„é€ è¯·æ±‚
        request = {
            "type": "ask_user_request",
            "question_id": question_id,
            "question": question,
            "question_type": question_type,
            "options": options,
            "default": default,
            "timeout": timeout
        }
        
        # æ³¨å†Œå¾…å¤„ç†çš„äº¤äº’
        pending = PendingInteraction(
            question_id=question_id,
            task_context=task_context,
            callback=on_answer,
            default=default
        )
        self._pending_interactions[question_id] = pending
        
        # å‘é€è¯¢é—®ï¼ˆå¼‚æ­¥ï¼‰
        asyncio.create_task(self._send_question_async(request))
        
        # è®¾ç½®è¶…æ—¶
        self.timeout_manager.set_timeout(
            identifier=question_id,
            timeout_seconds=timeout,
            callback=lambda: self._handle_timeout(question_id)
        )
        
        self.stats["total_asked"] += 1
        
        print(f"[InteractionManager] â“ Question sent: {question[:50]}")
        
        return question_id
    
    async def _send_question_async(self, request: Dict):
        """å‘é€è¯¢é—®æ¶ˆæ¯"""
        try:
            if self.tools and hasattr(self.tools, 'send_message_async'):
                await self.tools.send_message_async(request)
        except Exception as e:
            print(f"[InteractionManager] Failed to send: {e}")
    
    def handle_user_answer(self, response: Dict):
        """å¤„ç†ç”¨æˆ·å›ç­”"""
        question_id = response.get("question_id")
        answer = response.get("answer")
        cancelled = response.get("cancelled", False)
        
        pending = self._pending_interactions.pop(question_id, None)
        if not pending:
            print(f"[InteractionManager] Unknown question: {question_id}")
            return
        
        self.timeout_manager.cancel_timeout(question_id)
        
        if cancelled:
            answer = pending.default
            self.stats["total_cancelled"] += 1
        else:
            self.stats["total_answered"] += 1
        
        print(f"[InteractionManager] âœ… Answer: {str(answer)[:50]}")
        
        task_context = pending.task_context
        callback = pending.callback
        
        task_context.resume_with_answer(answer)
        
        if callback:
            try:
                if asyncio.iscoroutinefunction(callback):
                    asyncio.create_task(callback(answer))
                else:
                    callback(answer)
            except Exception as e:
                print(f"[InteractionManager] Callback error: {e}")
    
    def _handle_timeout(self, question_id: str):
        """å¤„ç†è¶…æ—¶"""
        pending = self._pending_interactions.pop(question_id, None)
        if not pending:
            return
        
        answer = pending.default
        self.stats["total_timeout"] += 1
        
        print(f"[InteractionManager] â° Timeout: {question_id}, default={answer}")
        
        task_context = pending.task_context
        callback = pending.callback
        
        task_context.resume_with_answer(answer)
        
        if callback:
            try:
                if asyncio.iscoroutinefunction(callback):
                    asyncio.create_task(callback(answer))
                else:
                    callback(answer)
            except Exception as e:
                print(f"[InteractionManager] Timeout callback error: {e}")
```

### 3.2.2 é›†æˆæµ‹è¯•

#### æ–‡ä»¶: `tests/agent/interaction/test_interaction_manager.py`

```python
"""æµ‹è¯•InteractionManager"""

import pytest
import asyncio
from unittest.mock import Mock, AsyncMock

from droidrun.agent.interaction.manager import InteractionManager
from droidrun.agent.interaction.task_context import TaskExecutionContext
from droidrun.agent.interaction.resume_context import ResumeContext, ResumeStrategy

@pytest.mark.asyncio
async def test_ask_user_async():
    """æµ‹è¯•å¼‚æ­¥è¯¢é—®"""
    # Mock tools
    tools = Mock()
    tools.send_message_async = AsyncMock()
    
    manager = InteractionManager(tools)
    
    # åˆ›å»ºä»»åŠ¡ä¸Šä¸‹æ–‡
    ctx = TaskExecutionContext("task-1", "æµ‹è¯•")
    manager.set_current_task_context(ctx)
    
    # è¯¢é—®ç”¨æˆ·
    question_id = manager.ask_user_async(
        task_context=ctx,
        question="æµ‹è¯•é—®é¢˜",
        question_type="text",
        default="é»˜è®¤å€¼",
        timeout=5
    )
    
    assert question_id is not None
    assert len(manager._pending_interactions) == 1
    assert manager.stats["total_asked"] == 1
    
    # ç­‰å¾…æ¶ˆæ¯å‘é€
    await asyncio.sleep(0.1)
    tools.send_message_async.assert_called_once()

@pytest.mark.asyncio
async def test_handle_user_answer():
    """æµ‹è¯•å¤„ç†ç”¨æˆ·å›ç­”"""
    manager = InteractionManager()
    
    ctx = TaskExecutionContext("task-2", "æµ‹è¯•")
    
    answered_value = None
    
    def callback(resume_ctx, answer):
        nonlocal answered_value
        answered_value = answer
    
    resume_ctx = ResumeContext(
        resume_id="r-1",
        step_index=0,
        action_name="test",
        action_func=lambda: None,
        strategy=ResumeStrategy.PARAMETER_FILL
    )
    
    # å‘èµ·è¯¢é—®
    question_id = manager.ask_user_async(
        task_context=ctx,
        question="æµ‹è¯•",
        default="é»˜è®¤",
        timeout=10,
        on_answer=lambda ans: callback(resume_ctx, ans)
    )
    
    # æš‚åœä»»åŠ¡
    ctx.pause_for_user_input(question_id, resume_ctx, callback)
    
    # æ¨¡æ‹Ÿç”¨æˆ·å›ç­”
    response = {
        "question_id": question_id,
        "answer": "ç”¨æˆ·å›ç­”",
        "cancelled": False
    }
    
    manager.handle_user_answer(response)
    
    # ç­‰å¾…å›è°ƒæ‰§è¡Œ
    await asyncio.sleep(0.1)
    
    assert answered_value == "ç”¨æˆ·å›ç­”"
    assert manager.stats["total_answered"] == 1
    assert len(manager._pending_interactions) == 0

@pytest.mark.asyncio
async def test_timeout_handling():
    """æµ‹è¯•è¶…æ—¶å¤„ç†"""
    manager = InteractionManager()
    
    ctx = TaskExecutionContext("task-3", "æµ‹è¯•")
    
    timeout_triggered = False
    timeout_value = None
    
    def callback(resume_ctx, answer):
        nonlocal timeout_triggered, timeout_value
        timeout_triggered = True
        timeout_value = answer
    
    resume_ctx = ResumeContext(
        resume_id="r-2",
        step_index=0,
        action_name="test",
        action_func=lambda: None,
        strategy=ResumeStrategy.PARAMETER_FILL
    )
    
    # å‘èµ·è¯¢é—®ï¼ˆçŸ­è¶…æ—¶ï¼‰
    question_id = manager.ask_user_async(
        task_context=ctx,
        question="æµ‹è¯•è¶…æ—¶",
        default="é»˜è®¤å€¼",
        timeout=1,  # 1ç§’è¶…æ—¶
        on_answer=lambda ans: callback(resume_ctx, ans)
    )
    
    ctx.pause_for_user_input(question_id, resume_ctx, callback)
    
    # ç­‰å¾…è¶…æ—¶
    await asyncio.sleep(1.5)
    
    assert timeout_triggered
    assert timeout_value == "é»˜è®¤å€¼"
    assert manager.stats["total_timeout"] == 1
```

### 3.2.3 Phase 2 éªŒæ”¶æ ‡å‡†

- [ ] æ‰€æœ‰é›†æˆæµ‹è¯•é€šè¿‡
- [ ] éé˜»å¡è¯¢é—®æœºåˆ¶å·¥ä½œæ­£å¸¸
- [ ] è¶…æ—¶å¤„ç†æ­£ç¡®
- [ ] ç”¨æˆ·å›ç­”èƒ½æ­£ç¡®è·¯ç”±åˆ°å›è°ƒ
- [ ] æ— å†…å­˜æ³„æ¼

---

## Phase 3: ask_userå·¥å…·ï¼ˆDay 6-7ï¼‰

### 3.3.1 å®ç°å†…å®¹

#### æ–‡ä»¶1: `droidrun/tools/websocket_tools.py` (ä¿®æ”¹)

```python
# åœ¨WebSocketToolsç±»ä¸­æ·»åŠ æ–¹æ³•

async def ask_user(
    self,
    question: str,
    question_type: str = "text",
    options: List[str] = None,
    default: str = None,
    timeout: int = 60
) -> str:
    """
    å‘ç”¨æˆ·æé—®ï¼ˆä¾›LLMè°ƒç”¨ï¼‰
    
    Args:
        question: é—®é¢˜å†…å®¹
        question_type: é—®é¢˜ç±»å‹ï¼ˆtext/choice/confirm/date/numberï¼‰
        options: é€‰é¡¹åˆ—è¡¨ï¼ˆchoiceç±»å‹æ—¶å¿…éœ€ï¼‰
        default: é»˜è®¤å€¼
        timeout: è¶…æ—¶æ—¶é—´ï¼ˆç§’ï¼‰
    
    Returns:
        ç”¨æˆ·çš„å›ç­”
    """
    if not self.interaction_manager:
        print("[WebSocketTools] No interaction manager, using default")
        return default or ""
    
    task_context = self.interaction_manager.get_current_task_context()
    if not task_context:
        print("[WebSocketTools] No active task context")
        return default or ""
    
    # åˆ›å»ºFutureç­‰å¾…ç”¨æˆ·å›ç­”
    answer_future = asyncio.Future()
    
    # åˆ›å»ºæ¢å¤ä¸Šä¸‹æ–‡
    from droidrun.agent.interaction.resume_context import (
        ResumeContext, 
        ResumeStrategy
    )
    
    resume_ctx = ResumeContext(
        resume_id=str(uuid.uuid4()),
        step_index=task_context.current_step,
        action_name="ask_user",
        action_func=lambda answer: answer,
        original_args=(),
        original_kwargs={
            "question": question,
            "question_type": question_type,
            "options": options
        },
        strategy=ResumeStrategy.PARAMETER_FILL,
        context_data={"question": question}
    )
    
    # å®šä¹‰å›è°ƒ
    def on_user_answer(resume_context, answer):
        if not answer_future.done():
            answer_future.set_result(answer)
    
    # å‘é€è¯¢é—®
    question_id = self.interaction_manager.ask_user_async(
        task_context=task_context,
        question=question,
        question_type=question_type,
        options=options,
        default=default,
        timeout=timeout,
        on_answer=lambda ans: on_user_answer(resume_ctx, ans)
    )
    
    # æš‚åœä»»åŠ¡
    task_context.pause_for_user_input(
        question_id=question_id,
        resume_context=resume_ctx,
        resume_callback=on_user_answer,
        reason=f"LLM asking: {question[:50]}"
    )
    
    print(f"[WebSocketTools] ğŸ¤” LLM asking: {question}")
    
    # ç­‰å¾…ç”¨æˆ·å›ç­”
    try:
        answer = await asyncio.wait_for(answer_future, timeout=timeout)
        print(f"[WebSocketTools] âœ… User answered: {str(answer)[:50]}")
        return answer
    except asyncio.TimeoutError:
        print(f"[WebSocketTools] â° Timeout, using default: {default}")
        return default or ""
```

#### æ–‡ä»¶2: `droidrun/agent/codeact/system_prompt.py` (ä¿®æ”¹)

```python
# æ·»åŠ äº¤äº’æŒ‡å¯¼åˆ°System Prompt

INTERACTION_GUIDANCE = """
## ğŸ¤ ç”¨æˆ·äº¤äº’èƒ½åŠ›

ä½ æ‹¥æœ‰ä¸»åŠ¨è¯¢é—®ç”¨æˆ·çš„èƒ½åŠ›ã€‚åœ¨ä»¥ä¸‹æƒ…å†µä¸‹ï¼Œä½¿ç”¨ ask_user() å·¥å…·ï¼š

### åœºæ™¯1ï¼šä¿¡æ¯ç¼ºå¤± âš ï¸
â€‹```python
# ä»»åŠ¡"è¯·æ˜å¤©çš„å‡"ç¼ºå°‘äº‹ç”±
reason = ask_user(
    question="è¯·æä¾›è¯·å‡äº‹ç”±ï¼ˆä¾‹å¦‚ï¼šå›å®¶æ¢äº²ã€èº«ä½“ä¸é€‚ï¼‰ï¼š",
    question_type="text",
    default="ç§äº‹"
)
```

### åœºæ™¯2ï¼šå¤šä¸ªé€‰é¡¹ âš ï¸
```python
# çœ‹åˆ°"å¹´ä¼‘å‡"å’Œ"ç—…å‡"ä¸¤ä¸ªæŒ‰é’®
leave_type = ask_user(
    question="è¯·é€‰æ‹©å‡æœŸç±»å‹ï¼š",
    question_type="choice",
    options=["å¹´ä¼‘å‡", "ç—…å‡", "äº‹å‡"]
)
```

### åœºæ™¯3ï¼šå…³é”®æ“ä½œç¡®è®¤ âš ï¸
```python
# å‡†å¤‡ç‚¹å‡»"åˆ é™¤"æŒ‰é’®
confirmed = ask_user(
    question="å³å°†åˆ é™¤æ•°æ®ï¼Œç¡®è®¤ç»§ç»­å—ï¼Ÿ",
    question_type="confirm"
)
if confirmed == "å¦":
    complete(success=False, output="ç”¨æˆ·å–æ¶ˆ")
```

### ask_userå·¥å…·ç­¾å
```python
def ask_user(
    question: str,           # é—®é¢˜ï¼ˆæ¸…æ™°ã€å…·ä½“ï¼‰
    question_type: str = "text",  # text/choice/confirm/date/number
    options: List[str] = None,    # choiceæ—¶çš„é€‰é¡¹
    default: str = None           # é»˜è®¤å€¼
) -> str:  # è¿”å›ç”¨æˆ·å›ç­”
```

### ä½¿ç”¨åŸåˆ™
- é—®é¢˜è¦æ¸…æ™°å…·ä½“
- æä¾›é€‰é¡¹æ¯”è‡ªç”±è¾“å…¥æ›´å¥½
- é¿å…è¿‡åº¦è¯¢é—®
- è®¾ç½®åˆç†é»˜è®¤å€¼
"""

# æ·»åŠ åˆ°å®Œæ•´System Prompt
SYSTEM_PROMPT = BASE_PROMPT + INTERACTION_GUIDANCE + TOOLS_DESCRIPTION
```

### 3.3.2 ç«¯åˆ°ç«¯æµ‹è¯•

#### æ–‡ä»¶: `tests/integration/test_ask_user_e2e.py`

â€‹```python
"""ask_userç«¯åˆ°ç«¯æµ‹è¯•"""

import pytest
import asyncio
from unittest.mock import Mock, AsyncMock, patch

@pytest.mark.asyncio
async def test_llm_ask_user_flow():
    """æµ‹è¯•LLMè°ƒç”¨ask_userçš„å®Œæ•´æµç¨‹"""
    
    # æ¨¡æ‹Ÿç¯å¢ƒè®¾ç½®
    from droidrun.agent.interaction.manager import InteractionManager
    from droidrun.agent.interaction.task_context import TaskExecutionContext
    from droidrun.tools.websocket_tools import WebSocketTools
    
    # åˆ›å»ºç»„ä»¶
    tools = WebSocketTools(device_id="test-device")
    manager = InteractionManager(tools)
    tools.interaction_manager = manager
    
    # åˆ›å»ºä»»åŠ¡
    ctx = TaskExecutionContext("task-1", "æµ‹è¯•ä»»åŠ¡")
    manager.set_current_task_context(ctx)
    
    # æ¨¡æ‹ŸLLMè°ƒç”¨ask_user
    async def simulate_llm_execution():
        # LLMç”Ÿæˆçš„ä»£ç ä¼šè°ƒç”¨
        answer = await tools.ask_user(
            question="è¯·é€‰æ‹©å‡æœŸç±»å‹",
            question_type="choice",
            options=["å¹´ä¼‘å‡", "ç—…å‡"],
            default="å¹´ä¼‘å‡"
        )
        return answer
    
    # å¯åŠ¨LLMæ‰§è¡Œï¼ˆéé˜»å¡ï¼‰
    llm_task = asyncio.create_task(simulate_llm_execution())
    
    # ç­‰å¾…è¯¢é—®å‘é€
    await asyncio.sleep(0.1)
    
    # éªŒè¯ä»»åŠ¡å·²æš‚åœ
    assert ctx.state.value == "waiting_user"
    assert len(manager._pending_interactions) == 1
    
    # è·å–question_id
    question_id = list(manager._pending_interactions.keys())[0]
    
    # æ¨¡æ‹Ÿç”¨æˆ·å›ç­”
    response = {
        "question_id": question_id,
        "answer": "ç—…å‡",
        "cancelled": False
    }
    
    manager.handle_user_answer(response)
    
    # ç­‰å¾…LLMæ¢å¤æ‰§è¡Œ
    answer = await llm_task
    
    # éªŒè¯ç»“æœ
    assert answer == "ç—…å‡"
    assert ctx.state.value == "running"

@pytest.mark.asyncio
async def test_ask_user_timeout():
    """æµ‹è¯•ask_userè¶…æ—¶"""
    from droidrun.agent.interaction.manager import InteractionManager
    from droidrun.agent.interaction.task_context import TaskExecutionContext
    from droidrun.tools.websocket_tools import WebSocketTools
    
    tools = WebSocketTools(device_id="test-device")
    manager = InteractionManager(tools)
    tools.interaction_manager = manager
    
    ctx = TaskExecutionContext("task-2", "æµ‹è¯•")
    manager.set_current_task_context(ctx)
    
    # è°ƒç”¨ask_userï¼ˆçŸ­è¶…æ—¶ï¼‰
    answer = await tools.ask_user(
        question="æµ‹è¯•è¶…æ—¶",
        question_type="text",
        default="é»˜è®¤å›ç­”",
        timeout=1
    )
    
    # åº”è¯¥è¿”å›é»˜è®¤å€¼
    assert answer == "é»˜è®¤å›ç­”"
```

### 3.3.3 Phase 3 éªŒæ”¶æ ‡å‡†

- [ ] ask_userå·¥å…·å¯ä»¥è¢«LLMè°ƒç”¨
- [ ] è¯¢é—®æ¶ˆæ¯èƒ½å‘é€åˆ°Androidç«¯
- [ ] ç”¨æˆ·å›ç­”èƒ½æ­£ç¡®è¿”å›ç»™LLM
- [ ] è¶…æ—¶æœºåˆ¶å·¥ä½œæ­£å¸¸
- [ ] System PromptæŒ‡å¯¼æœ‰æ•ˆ

---

## Phase 4: DroidAgenté›†æˆï¼ˆDay 8-9ï¼‰

### 3.4.1 å®ç°å†…å®¹

#### æ–‡ä»¶1: `droidrun/agent/interaction/lifecycle_manager.py`

```python
"""ä»»åŠ¡ç”Ÿå‘½å‘¨æœŸç®¡ç†å™¨"""

from dataclasses import dataclass, field
import asyncio
from typing import Dict, Optional, Any
import time

from .task_context import TaskExecutionContext

@dataclass
class TaskInfo:
    """ä»»åŠ¡ä¿¡æ¯"""
    task_id: str
    context: TaskExecutionContext
    created_at: float
    last_activity: float
    status: str
    
    completion_future: asyncio.Future = field(default_factory=asyncio.Future)
    lock: asyncio.Lock = field(default_factory=asyncio.Lock)

class TaskLifecycleManager:
    """ä»»åŠ¡ç”Ÿå‘½å‘¨æœŸç®¡ç†å™¨"""
    
    def __init__(self):
        self.tasks: Dict[str, TaskInfo] = {}
        self._global_lock = asyncio.Lock()
    
    async def create_task(
        self, 
        task_id: str, 
        context: TaskExecutionContext
    ) -> TaskInfo:
        """åˆ›å»ºæ–°ä»»åŠ¡"""
        async with self._global_lock:
            if task_id in self.tasks:
                raise ValueError(f"Task {task_id} already exists")
            
            task_info = TaskInfo(
                task_id=task_id,
                context=context,
                created_at=time.time(),
                last_activity=time.time(),
                status="active"
            )
            
            self.tasks[task_id] = task_info
            print(f"[LifecycleManager] Task created: {task_id}")
            
            return task_info
    
    async def complete_task(self, task_id: str, result: Any):
        """æ ‡è®°ä»»åŠ¡å®Œæˆ"""
        async with self._global_lock:
            task_info = self.tasks.get(task_id)
            if not task_info:
                return
        
        async with task_info.lock:
            if task_info.status in ["completed", "failed"]:
                return
            
            task_info.status = "completed"
            task_info.completion_future.set_result(result)
            print(f"[LifecycleManager] âœ… Task completed: {task_id}")
    
    async def fail_task(self, task_id: str, error: Exception):
        """æ ‡è®°ä»»åŠ¡å¤±è´¥"""
        async with self._global_lock:
            task_info = self.tasks.get(task_id)
            if not task_info:
                return
        
        async with task_info.lock:
            task_info.status = "failed"
            task_info.completion_future.set_exception(error)
            print(f"[LifecycleManager] âŒ Task failed: {task_id}")
```

#### æ–‡ä»¶2: [droidrun/agent/droid/droid_agent.py](cci:7://file:///e:/WorkRelated/ResumeScreeningRelated/GUI/droidrun/droidrun/agent/droid/droid_agent.py:0:0-0:0) (å…³é”®ä¿®æ”¹)

```python
# åœ¨DroidAgentç±»ä¸­æ·»åŠ /ä¿®æ”¹

def __init__(self, ...):
    # ç°æœ‰åˆå§‹åŒ–...
    
    # æ–°å¢ï¼šäº¤äº’ç»„ä»¶
    from droidrun.agent.interaction.manager import InteractionManager
    from droidrun.agent.interaction.lifecycle_manager import TaskLifecycleManager
    
    self.interaction_manager = InteractionManager(self.tools_instance)
    self.lifecycle_manager = TaskLifecycleManager()
    
    # æ³¨å…¥åˆ°tools
    self.tools_instance.interaction_manager = self.interaction_manager
    
    # ä»»åŠ¡ä¸Šä¸‹æ–‡
    self.task_context = None

async def run(self):
    """æ‰§è¡Œä»»åŠ¡ï¼ˆæ”¹è¿›ç‰ˆï¼‰"""
    import uuid
    from droidrun.agent.interaction.task_context import TaskExecutionContext
    
    # 1. åˆ›å»ºä»»åŠ¡ä¸Šä¸‹æ–‡
    task_id = str(uuid.uuid4())
    self.task_context = TaskExecutionContext(
        task_id=task_id,
        goal=self.goal,
        task_type=self.current_task_type
    )
    
    # 2. æ³¨å†Œåˆ°ç”Ÿå‘½å‘¨æœŸç®¡ç†å™¨
    await self.lifecycle_manager.create_task(task_id, self.task_context)
    
    # 3. è®¾ç½®ä¸ºå½“å‰ä»»åŠ¡
    self.interaction_manager.set_current_task_context(self.task_context)
    
    try:
        # 4. æ‰§è¡Œä»»åŠ¡
        result = await self._execute_task_internal()
        
        # 5. æ ‡è®°å®Œæˆ
        await self.lifecycle_manager.complete_task(task_id, result)
        
        return result
    
    except Exception as e:
        await self.lifecycle_manager.fail_task(task_id, e)
        raise

async def handle_user_answer(self, task_id: str, question_id: str, answer: Any):
    """å¤„ç†ç”¨æˆ·å›ç­”ï¼ˆå¤–éƒ¨è°ƒç”¨ï¼‰"""
    # è½¬å‘åˆ°InteractionManager
    response = {
        "question_id": question_id,
        "answer": answer,
        "cancelled": False
    }
    
    self.interaction_manager.handle_user_answer(response)
```

### 3.4.2 å®Œæ•´æµç¨‹æµ‹è¯•

#### æ–‡ä»¶: `tests/integration/test_droidagent_interaction.py`

```python
"""æµ‹è¯•DroidAgentäº¤äº’é›†æˆ"""

import pytest
import asyncio
from unittest.mock import Mock, AsyncMock, patch

@pytest.mark.asyncio
async def test_droidagent_with_interaction():
    """æµ‹è¯•DroidAgentå®Œæ•´äº¤äº’æµç¨‹"""
    
    # æ¨¡æ‹ŸCodeActAgent
    class MockCodeActAgent:
        def __init__(self, goal, tools, llm, **kwargs):
            self.goal = goal
            self.tools = tools
        
        async def run(self):
            # æ¨¡æ‹ŸLLMæ‰§è¡Œè¿‡ç¨‹ä¸­è°ƒç”¨ask_user
            answer = await self.tools.ask_user(
                question="è¯·æä¾›äº‹ç”±",
                question_type="text",
                default="ç§äº‹"
            )
            
            return {
                "success": True,
                "output": f"å·²æäº¤ï¼Œäº‹ç”±ï¼š{answer}"
            }
    
    # åˆ›å»ºDroidAgent
    from droidrun.agent.droid.droid_agent import DroidAgent
    
    agent = DroidAgent(
        goal="è¯·æ˜å¤©çš„å‡",
        tools_instance=Mock(),
        llm=Mock()
    )
    
    # æ›¿æ¢CodeActAgent
    with patch('droidrun.agent.droid.droid_agent.CodeActAgent', MockCodeActAgent):
        # å¯åŠ¨ä»»åŠ¡
        task = asyncio.create_task(agent.run())
        
        # ç­‰å¾…è¯¢é—®å‘é€
        await asyncio.sleep(0.5)
        
        # éªŒè¯ä»»åŠ¡å·²æš‚åœ
        assert agent.task_context.state.value == "waiting_user"
        
        # è·å–question_id
        question_id = agent.task_context.pending_question_id
        
        # æ¨¡æ‹Ÿç”¨æˆ·å›ç­”
        await agent.handle_user_answer(
            task_id=agent.task_context.task_id,
            question_id=question_id,
            answer="ç”Ÿç—…"
        )
        
        # ç­‰å¾…ä»»åŠ¡å®Œæˆ
        result = await task
        
        # éªŒè¯ç»“æœ
        assert result["success"]
        assert "ç”Ÿç—…" in result["output"]
```

### 3.4.3 Phase 4 éªŒæ”¶æ ‡å‡†

- [ ] DroidAgentèƒ½åˆ›å»ºå’Œç®¡ç†ä»»åŠ¡ä¸Šä¸‹æ–‡
- [ ] ä»»åŠ¡å¯ä»¥æš‚åœå¹¶æ¢å¤
- [ ] ç”Ÿå‘½å‘¨æœŸç®¡ç†æ­£ç¡®
- [ ] ç”¨æˆ·å›ç­”èƒ½æ­£ç¡®è·¯ç”±
- [ ] å®Œæ•´æµç¨‹æµ‹è¯•é€šè¿‡

---

## Phase 5: Androidç«¯ + ä¼˜åŒ–ï¼ˆDay 10-12ï¼‰

### 3.5.1 Androidå®ç°ï¼ˆç®€åŒ–ï¼‰

#### æ–‡ä»¶: `app/src/main/java/com/droidrun/dialog/DialogFactory.kt`

```kotlin
class DialogFactory(
    private val activity: Activity,
    private val onAnswer: (questionId: String, answer: String?, cancelled: Boolean) -> Unit
) {
    
    fun createDialog(
        questionId: String,
        questionType: String,
        question: String,
        options: List<String>? = null,
        default: String? = null
    ): AlertDialog {
        return when (questionType) {
            "text", "number" -> createInputDialog(questionId, question, default, questionType)
            "choice" -> createChoiceDialog(questionId, question, options ?: emptyList())
            "confirm" -> createConfirmDialog(questionId, question)
            "date" -> createDateDialog(questionId, question)
            else -> createInputDialog(questionId, question, default, "text")
        }
    }
    
    private fun createInputDialog(
        questionId: String,
        question: String,
        default: String?,
        type: String
    ): AlertDialog {
        val input = EditText(activity).apply {
            setText(default)
            inputType = when (type) {
                "number" -> InputType.TYPE_CLASS_NUMBER
                else -> InputType.TYPE_CLASS_TEXT
            }
            setPadding(50, 40, 50, 40)
        }
        
        return MaterialAlertDialogBuilder(activity)
            .setTitle("éœ€è¦æ‚¨çš„è¾“å…¥")
            .setMessage(question)
            .setView(input)
            .setPositiveButton("ç¡®å®š") { _, _ ->
                onAnswer(questionId, input.text.toString(), false)
            }
            .setNegativeButton("å–æ¶ˆ") { _, _ ->
                onAnswer(questionId, null, true)
            }
            .setCancelable(false)
            .create()
    }
    
    private fun createChoiceDialog(
        questionId: String,
        question: String,
        options: List<String>
    ): AlertDialog {
        return MaterialAlertDialogBuilder(activity)
            .setTitle("è¯·é€‰æ‹©")
            .setMessage(question)
            .setItems(options.toTypedArray()) { _, which ->
                onAnswer(questionId, options[which], false)
            }
            .setNegativeButton("å–æ¶ˆ") { _, _ ->
                onAnswer(questionId, null, true)
            }
            .setCancelable(false)
            .create()
    }
    
    private fun createConfirmDialog(
        questionId: String,
        question: String
    ): AlertDialog {
        return MaterialAlertDialogBuilder(activity)
            .setTitle("ç¡®è®¤")
            .setMessage(question)
            .setPositiveButton("ç¡®è®¤") { _, _ ->
                onAnswer(questionId, "æ˜¯", false)
            }
            .setNegativeButton("å–æ¶ˆ") { _, _ ->
                onAnswer(questionId, "å¦", false)
            }
            .setCancelable(false)
            .create()
    }
}
```

#### æ–‡ä»¶: `app/src/main/java/com/droidrun/MessageHandler.kt` (ä¿®æ”¹)

```kotlin
class MessageHandler(
    private val activity: Activity,
    private val webSocketClient: WebSocketClient
) {
    private val dialogFactory = DialogFactory(activity) { questionId, answer, cancelled ->
        sendAnswer(questionId, answer, cancelled)
    }
    
    private var currentDialog: AlertDialog? = null
    
    fun handleMessage(message: JSONObject) {
        when (message.getString("type")) {
            "ask_user_request" -> handleAskUserRequest(message)
            // å…¶ä»–æ¶ˆæ¯ç±»å‹...
        }
    }
    
    private fun handleAskUserRequest(message: JSONObject) {
        val questionId = message.getString("question_id")
        val questionType = message.getString("question_type")
        val question = message.getString("question")
        val default = message.optString("default", null)
        
        val options = message.optJSONArray("options")?.let {
            List(it.length()) { i -> it.getString(i) }
        }
        
        activity.runOnUiThread {
            currentDialog?.dismiss()
            
            currentDialog = dialogFactory.createDialog(
                questionId, questionType, question, options, default
            )
            
            currentDialog?.show()
        }
    }
    
    private fun sendAnswer(
        questionId: String,
        answer: String?,
        cancelled: Boolean
    ) {
        val response = JSONObject().apply {
            put("type", "ask_user_response")
            put("question_id", questionId)
            put("answer", answer ?: "")
            put("cancelled", cancelled)
            put("timestamp", System.currentTimeMillis() / 1000)
        }
        
        webSocketClient.send(response.toString())
        currentDialog = null
    }
}
```

### 3.5.2 çœŸæœºæµ‹è¯•æ–¹æ¡ˆ

#### æµ‹è¯•åœºæ™¯1: å‚æ•°ç¼ºå¤±è¯¢é—®

```
å‡†å¤‡ï¼š
1. å¯åŠ¨Androidåº”ç”¨
2. è¿æ¥WebSocketæœåŠ¡å™¨

æ“ä½œï¼š
1. ç”¨æˆ·è¾“å…¥ï¼š"è¯·æ˜å¤©çš„å‡"ï¼ˆç¼ºå°‘äº‹ç”±ï¼‰
2. LLMæ£€æµ‹åˆ°ç¼ºå¤±ï¼Œè°ƒç”¨ask_user
3. Androidæ˜¾ç¤ºè¾“å…¥æ¡†ï¼š"è¯·æä¾›è¯·å‡äº‹ç”±"
4. ç”¨æˆ·è¾“å…¥ï¼š"ç”Ÿç—…"
5. ç»§ç»­æ‰§è¡Œä»»åŠ¡

éªŒè¯ï¼š
- [ ] å¯¹è¯æ¡†æ­£ç¡®æ˜¾ç¤º
- [ ] ç”¨æˆ·è¾“å…¥èƒ½å‘é€å›æœåŠ¡å™¨
- [ ] ä»»åŠ¡ç»§ç»­æ‰§è¡Œ
- [ ] æœ€ç»ˆæäº¤åŒ…å«äº‹ç”±"ç”Ÿç—…"
```

#### æµ‹è¯•åœºæ™¯2: å¤šé€‰é¡¹æ¶ˆæ­§

```
å‡†å¤‡ï¼šåŒä¸Š

æ“ä½œï¼š
1. ç”¨æˆ·è¾“å…¥ï¼š"è¯·å‡"
2. UIä¸­æœ‰"å¹´ä¼‘å‡"å’Œ"ç—…å‡"æŒ‰é’®
3. LLMè°ƒç”¨ask_userè®©ç”¨æˆ·é€‰æ‹©
4. Androidæ˜¾ç¤ºé€‰é¡¹å¯¹è¯æ¡†
5. ç”¨æˆ·é€‰æ‹©"ç—…å‡"
6. ç»§ç»­æ‰§è¡Œ

éªŒè¯ï¼š
- [ ] é€‰é¡¹å¯¹è¯æ¡†æ­£ç¡®æ˜¾ç¤º
- [ ] ç”¨æˆ·é€‰æ‹©èƒ½æ­£ç¡®å‘é€
- [ ] ä»»åŠ¡é€‰æ‹©äº†æ­£ç¡®çš„æŒ‰é’®
```

#### æµ‹è¯•åœºæ™¯3: å…³é”®æ“ä½œç¡®è®¤

```
å‡†å¤‡ï¼šåŒä¸Š

æ“ä½œï¼š
1. ç”¨æˆ·è¾“å…¥ï¼š"åˆ é™¤æ‰€æœ‰æ•°æ®"
2. LLMå‡†å¤‡ç‚¹å‡»åˆ é™¤æŒ‰é’®
3. è°ƒç”¨ask_userç¡®è®¤
4. Androidæ˜¾ç¤ºç¡®è®¤å¯¹è¯æ¡†
5. ç”¨æˆ·ç‚¹å‡»"å–æ¶ˆ"
6. ä»»åŠ¡åœæ­¢

éªŒè¯ï¼š
- [ ] ç¡®è®¤å¯¹è¯æ¡†æ˜¾ç¤º
- [ ] å–æ¶ˆèƒ½æ­£ç¡®å¤„ç†
- [ ] ä»»åŠ¡æœªæ‰§è¡Œåˆ é™¤æ“ä½œ
```

### 3.5.3 Phase 5 éªŒæ”¶æ ‡å‡†

- [ ] Androidå¯¹è¯æ¡†æ­£å¸¸æ˜¾ç¤º
- [ ] æ‰€æœ‰é—®é¢˜ç±»å‹éƒ½èƒ½æ­£ç¡®å¤„ç†
- [ ] çœŸæœºæµ‹è¯•é€šè¿‡æ‰€æœ‰åœºæ™¯
- [ ] æ— å´©æºƒã€æ— å†…å­˜æ³„æ¼
- [ ] ç”¨æˆ·ä½“éªŒæµç•…

---

## 4. é›†æˆæµ‹è¯•æ€»ä½“æ–¹æ¡ˆ

### 4.1 æµ‹è¯•é‡‘å­—å¡”

```
              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
              â”‚  æ‰‹åŠ¨æ¢ç´¢æµ‹è¯•    â”‚  1-2åœºæ™¯
              â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                    â†‘
          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
          â”‚   ç«¯åˆ°ç«¯æµ‹è¯•ï¼ˆE2Eï¼‰    â”‚  5-10åœºæ™¯
          â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                    â†‘
      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
      â”‚      é›†æˆæµ‹è¯•ï¼ˆIntegrationï¼‰     â”‚  20-30æµ‹è¯•
      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                    â†‘
  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  â”‚           å•å…ƒæµ‹è¯•ï¼ˆUnitï¼‰                 â”‚  50+æµ‹è¯•
  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 4.2 å…³é”®é›†æˆæµ‹è¯•ç‚¹

#### æµ‹è¯•1: å®Œæ•´è¯¢é—®-å›ç­”æµç¨‹

```python
@pytest.mark.integration
async def test_complete_ask_answer_flow():
    """æµ‹è¯•å®Œæ•´çš„è¯¢é—®-å›ç­”æµç¨‹"""
    # è®¾ç½®
    agent = setup_test_agent()
    
    # å¯åŠ¨ä»»åŠ¡ï¼ˆä¼šè§¦å‘è¯¢é—®ï¼‰
    task = asyncio.create_task(agent.run())
    
    # ç­‰å¾…è¯¢é—®
    await wait_for_question()
    
    # æ¨¡æ‹Ÿç”¨æˆ·å›ç­”
    await simulate_user_answer("æµ‹è¯•å›ç­”")
    
    # ç­‰å¾…ä»»åŠ¡å®Œæˆ
    result = await task
    
    # éªŒè¯
    assert result["success"]
    assert "æµ‹è¯•å›ç­”" in result["output"]
```

#### æµ‹è¯•2: å¹¶å‘å¤šä»»åŠ¡

```python
@pytest.mark.integration
async def test_concurrent_tasks():
    """æµ‹è¯•å¹¶å‘å¤šä¸ªä»»åŠ¡"""
    # å¯åŠ¨3ä¸ªä»»åŠ¡
    tasks = [
        asyncio.create_task(run_task("ä»»åŠ¡1")),
        asyncio.create_task(run_task("ä»»åŠ¡2")),
        asyncio.create_task(run_task("ä»»åŠ¡3"))
    ]
    
    # ç­‰å¾…æ‰€æœ‰è¯¢é—®
    questions = await wait_for_multiple_questions(3)
    
    # ä¾æ¬¡å›ç­”
    for q in questions:
        await answer_question(q.question_id, "å›ç­”")
    
    # ç­‰å¾…æ‰€æœ‰å®Œæˆ
    results = await asyncio.gather(*tasks)
    
    # éªŒè¯
    assert all(r["success"] for r in results)
```

#### æµ‹è¯•3: è¶…æ—¶å’Œé”™è¯¯å¤„ç†

```python
@pytest.mark.integration
async def test_timeout_handling():
    """æµ‹è¯•è¶…æ—¶å¤„ç†"""
    agent = setup_test_agent()
    
    # å¯åŠ¨ä»»åŠ¡ï¼ˆçŸ­è¶…æ—¶ï¼‰
    task = asyncio.create_task(
        agent.run_with_timeout(timeout=5)
    )
    
    # ç­‰å¾…è¯¢é—®
    await wait_for_question()
    
    # ä¸å›ç­”ï¼Œç­‰å¾…è¶…æ—¶
    await asyncio.sleep(6)
    
    # éªŒè¯ä½¿ç”¨äº†é»˜è®¤å€¼
    result = await task
    assert "é»˜è®¤å€¼" in result["output"]
```

### 4.3 æµ‹è¯•ç¯å¢ƒé…ç½®

#### å¼€å‘ç¯å¢ƒ

```yaml
# tests/config/test_config.yaml

test_mode: true
mock_android: true
llm_provider: "mock"  # ä½¿ç”¨Mock LLM

interaction:
  default_timeout: 5  # æµ‹è¯•æ—¶ä½¿ç”¨çŸ­è¶…æ—¶
  enable_real_dialogs: false

logging:
  level: DEBUG
  capture_output: true
```

#### CIç¯å¢ƒ

```yaml
# .github/workflows/integration_test.yml

name: Integration Tests

on: [push, pull_request]

jobs:
  test:
    runs-on: ubuntu-latest
    
    steps:
      - uses: actions/checkout@v2
      
      - name: Set up Python
        uses: actions/setup-python@v2
        with:
          python-version: 3.9
      
      - name: Install dependencies
        run: |
          pip install -r requirements.txt
          pip install pytest pytest-asyncio pytest-cov
      
      - name: Run integration tests
        run: |
          pytest tests/integration/ -v --cov=droidrun/agent/interaction
      
      - name: Upload coverage
        uses: codecov/codecov-action@v2
```

---

## 5. éªŒæ”¶æ ‡å‡†

### 5.1 åŠŸèƒ½éªŒæ”¶

| åŠŸèƒ½ç‚¹          | éªŒæ”¶æ ‡å‡†             | æµ‹è¯•æ–¹æ³•     |
| --------------- | -------------------- | ------------ |
| **éé˜»å¡è¯¢é—®**  | è¯¢é—®ä¸é˜»å¡å…¶ä»–ä»»åŠ¡   | å¹¶å‘æµ‹è¯•     |
| **æš‚åœ/æ¢å¤**   | ä»»åŠ¡èƒ½æ­£ç¡®æš‚åœå’Œæ¢å¤ | çŠ¶æ€è½¬æ¢æµ‹è¯• |
| **è¶…æ—¶å¤„ç†**    | è¶…æ—¶åä½¿ç”¨é»˜è®¤å€¼     | è¶…æ—¶æµ‹è¯•     |
| **LLMé›†æˆ**     | LLMèƒ½è°ƒç”¨ask_user    | E2Eæµ‹è¯•      |
| **Androidå±•ç¤º** | å¯¹è¯æ¡†æ­£ç¡®æ˜¾ç¤º       | çœŸæœºæµ‹è¯•     |

### 5.2 æ€§èƒ½éªŒæ”¶

| æŒ‡æ ‡             | ç›®æ ‡             | æµ‹è¯•æ–¹æ³•   |
| ---------------- | ---------------- | ---------- |
| **è¯¢é—®å“åº”æ—¶é—´** | < 500ms          | æ€§èƒ½æµ‹è¯•   |
| **å¹¶å‘å¤„ç†èƒ½åŠ›** | 10ä¸ªå¹¶å‘ä»»åŠ¡     | å‹åŠ›æµ‹è¯•   |
| **å†…å­˜å ç”¨**     | < 100MBå¢é‡      | å†…å­˜ç›‘æ§   |
| **æ— å†…å­˜æ³„æ¼**   | é•¿æ—¶é—´è¿è¡Œæ— æ³„æ¼ | é•¿æ—¶é—´æµ‹è¯• |

### 5.3 è´¨é‡éªŒæ”¶

| æŒ‡æ ‡               | ç›®æ ‡          | æµ‹è¯•æ–¹æ³•    |
| ------------------ | ------------- | ----------- |
| **å•å…ƒæµ‹è¯•è¦†ç›–ç‡** | > 90%         | pytest-cov  |
| **é›†æˆæµ‹è¯•é€šè¿‡ç‡** | 100%          | CI          |
| **ä»£ç å®¡æŸ¥**       | 2äººå®¡æŸ¥é€šè¿‡   | Code Review |
| **æ–‡æ¡£å®Œæ•´æ€§**     | æ‰€æœ‰APIæœ‰æ–‡æ¡£ | æ–‡æ¡£æ£€æŸ¥    |

---

## 6. é£é™©æ§åˆ¶

### 6.1 æŠ€æœ¯é£é™©

| é£é™©                | å½±å“         | ç¼“è§£æªæ–½          |
| ------------------- | ------------ | ----------------- |
| **WebSocketæ–­è¿**   | è¯¢é—®æ¶ˆæ¯ä¸¢å¤± | å®ç°é‡è¿æœºåˆ¶      |
| **Androidè¿›ç¨‹æ€æ­»** | å¯¹è¯æ¡†æ¶ˆå¤±   | æœåŠ¡å™¨è®°å½•çŠ¶æ€    |
| **LLMä¸è°ƒç”¨å·¥å…·**   | åŠŸèƒ½å¤±æ•ˆ     | å¼ºåŒ–System Prompt |
| **å¹¶å‘ç«æ€**        | çŠ¶æ€æ··ä¹±     | ä½¿ç”¨é”æœºåˆ¶        |

### 6.2 å®æ–½é£é™©

| é£é™© | å½±å“ | ç¼“è§£æªæ–½

# ğŸ¯ äº¤äº’å¼æ‰§è¡Œå®Œæ•´å®æ–½æ–¹æ¡ˆï¼ˆç²¾ç®€ç‰ˆï¼‰

## ğŸ“‹ æ€»ä½“æ¶æ„

```
Phase 1 (2å¤©): åŸºç¡€æ•°æ®ç»“æ„
Phase 2 (2å¤©): äº¤äº’ç®¡ç†å™¨  
Phase 3 (2å¤©): ask_userå·¥å…·
Phase 4 (2å¤©): DroidAgenté›†æˆ
Phase 5 (2å¤©): Androidç«¯ + æµ‹è¯•
```

---

## Phase 1: åŸºç¡€æ•°æ®ç»“æ„ï¼ˆDay 1-2ï¼‰

### å®ç°æ–‡ä»¶

**1. `droidrun/agent/interaction/task_state.py`**
```python
from enum import Enum

class TaskState(Enum):
    INITIALIZED = "initialized"
    RUNNING = "running"
    WAITING_USER = "waiting_user"
    COMPLETED = "completed"
    FAILED = "failed"

class ResumeStrategy(Enum):
    REPLACE_PARAM = "replace_param"
    CONFIRM_CANCEL = "confirm_cancel"
    PARAMETER_FILL = "parameter_fill"
```

**2. `droidrun/agent/interaction/resume_context.py`**
- ä¿å­˜å®Œæ•´çš„åŠ¨ä½œä¸Šä¸‹æ–‡ï¼ˆå‡½æ•°ã€å‚æ•°ï¼‰
- `apply_answer()`: åº”ç”¨ç”¨æˆ·å›ç­”åˆ°å‚æ•°
- `execute_with_modified_params()`: æ‰§è¡Œä¿®æ”¹åçš„åŠ¨ä½œ

**3. `droidrun/agent/interaction/task_context.py`**
- ç®¡ç†ä»»åŠ¡çŠ¶æ€
- `pause_for_user_input()`: æš‚åœä»»åŠ¡
- `resume_with_answer()`: æ¢å¤ä»»åŠ¡

### æµ‹è¯•
```bash
pytest tests/agent/interaction/test_resume_context.py -v
pytest tests/agent/interaction/test_task_context.py -v
```

**éªŒæ”¶**: å•å…ƒæµ‹è¯•è¦†ç›–ç‡ > 90%

---

## Phase 2: äº¤äº’ç®¡ç†å™¨ï¼ˆDay 3-4ï¼‰

### å®ç°æ–‡ä»¶

**1. `droidrun/agent/interaction/manager.py`**
```python
class InteractionManager:
    def ask_user_async(self, task_context, question, ...):
        # 1. ç”Ÿæˆquestion_id
        # 2. å‘é€æ¶ˆæ¯ï¼ˆéé˜»å¡ï¼‰
        # 3. æ³¨å†Œå›è°ƒ
        # 4. è®¾ç½®è¶…æ—¶
        return question_id
    
    def handle_user_answer(self, response):
        # 1. æŸ¥æ‰¾pendingäº¤äº’
        # 2. å–æ¶ˆè¶…æ—¶
        # 3. æ¢å¤ä»»åŠ¡
        # 4. è§¦å‘å›è°ƒ
```

**2. `droidrun/agent/interaction/timeout_manager.py`**
- ç»Ÿä¸€ç®¡ç†æ‰€æœ‰è¶…æ—¶ä»»åŠ¡

### æµ‹è¯•
```python
# æµ‹è¯•éé˜»å¡è¯¢é—®
async def test_ask_user_async():
    manager = InteractionManager()
    question_id = manager.ask_user_async(...)
    assert question_id is not None

# æµ‹è¯•è¶…æ—¶
async def test_timeout():
    manager = InteractionManager()
    question_id = manager.ask_user_async(timeout=1)
    await asyncio.sleep(1.5)
    # éªŒè¯ä½¿ç”¨äº†é»˜è®¤å€¼
```

**éªŒæ”¶**: éé˜»å¡æœºåˆ¶å·¥ä½œæ­£å¸¸ï¼Œè¶…æ—¶å¤„ç†æ­£ç¡®

---

## Phase 3: ask_userå·¥å…·ï¼ˆDay 5-6ï¼‰

### å®ç°æ–‡ä»¶

**1. `droidrun/tools/websocket_tools.py` (æ·»åŠ æ–¹æ³•)**
```python
async def ask_user(self, question, question_type="text", options=None, default=None):
    # 1. è·å–å½“å‰ä»»åŠ¡ä¸Šä¸‹æ–‡
    # 2. åˆ›å»ºResumeContext
    # 3. è°ƒç”¨interaction_manager.ask_user_async()
    # 4. æš‚åœä»»åŠ¡
    # 5. ç­‰å¾…Futureè¿”å›ç»“æœ
    return answer
```

**2. `droidrun/agent/codeact/system_prompt.py` (å¢å¼º)**
```python
INTERACTION_GUIDANCE = """
ä½ å¯ä»¥ä½¿ç”¨ ask_user() å·¥å…·ï¼š

åœºæ™¯1: ä¿¡æ¯ç¼ºå¤±
reason = ask_user("è¯·æä¾›è¯·å‡äº‹ç”±ï¼š", "text", default="ç§äº‹")

åœºæ™¯2: å¤šä¸ªé€‰é¡¹
choice = ask_user("é€‰æ‹©å‡æœŸç±»å‹ï¼š", "choice", options=["å¹´ä¼‘å‡","ç—…å‡"])

åœºæ™¯3: å…³é”®æ“ä½œ
confirmed = ask_user("ç¡®è®¤åˆ é™¤ï¼Ÿ", "confirm")
"""
```

### æµ‹è¯•
```python
# ç«¯åˆ°ç«¯æµ‹è¯•
async def test_llm_ask_user():
    # 1. æ¨¡æ‹ŸLLMè°ƒç”¨ask_user
    # 2. éªŒè¯ä»»åŠ¡æš‚åœ
    # 3. æ¨¡æ‹Ÿç”¨æˆ·å›ç­”
    # 4. éªŒè¯ä»»åŠ¡æ¢å¤
    # 5. éªŒè¯è¿”å›å€¼æ­£ç¡®
```

**éªŒæ”¶**: LLMèƒ½è°ƒç”¨ask_userï¼Œå®Œæ•´æµç¨‹é€šè¿‡

---

## Phase 4: DroidAgenté›†æˆï¼ˆDay 7-8ï¼‰

### å®ç°æ–‡ä»¶

**1. [droidrun/agent/droid/droid_agent.py](cci:7://file:///e:/WorkRelated/ResumeScreeningRelated/GUI/droidrun/droidrun/agent/droid/droid_agent.py:0:0-0:0) (ä¿®æ”¹)**
```python
def __init__(self):
    self.interaction_manager = InteractionManager(self.tools_instance)
    self.lifecycle_manager = TaskLifecycleManager()
    self.tools_instance.interaction_manager = self.interaction_manager

async def run(self):
    # 1. åˆ›å»ºTaskExecutionContext
    # 2. æ³¨å†Œåˆ°lifecycle_manager
    # 3. è®¾ç½®ä¸ºcurrent_task_context
    # 4. æ‰§è¡Œä»»åŠ¡
    # 5. æ ‡è®°å®Œæˆ/å¤±è´¥
```

### æµ‹è¯•
```python
# å®Œæ•´æµç¨‹æµ‹è¯•
async def test_droidagent_interaction():
    agent = DroidAgent(goal="è¯·æ˜å¤©çš„å‡")
    task = asyncio.create_task(agent.run())
    
    # ç­‰å¾…è¯¢é—®
    await asyncio.sleep(0.5)
    assert agent.task_context.state == TaskState.WAITING_USER
    
    # å›ç­”
    await agent.handle_user_answer(...)
    
    # éªŒè¯å®Œæˆ
    result = await task
    assert result["success"]
```

**éªŒæ”¶**: å®Œæ•´æµç¨‹é€šè¿‡ï¼Œä»»åŠ¡ç”Ÿå‘½å‘¨æœŸç®¡ç†æ­£ç¡®

---

## Phase 5: Androidç«¯ï¼ˆDay 9-10ï¼‰

### å®ç°æ–‡ä»¶

**1. `DialogFactory.kt`**
```kotlin
class DialogFactory {
    fun createDialog(questionId, questionType, question, options, default): AlertDialog {
        return when (questionType) {
            "text" -> createInputDialog(...)
            "choice" -> createChoiceDialog(...)
            "confirm" -> createConfirmDialog(...)
            else -> createInputDialog(...)
        }
    }
}
```

**2. `MessageHandler.kt` (ä¿®æ”¹)**
```kotlin
fun handleMessage(message: JSONObject) {
    when (message.getString("type")) {
        "ask_user_request" -> {
            val dialog = dialogFactory.createDialog(...)
            dialog.show()
        }
    }
}

private fun sendAnswer(questionId, answer, cancelled) {
    val response = JSONObject().apply {
        put("type", "ask_user_response")
        put("question_id", questionId)
        put("answer", answer)
        put("cancelled", cancelled)
    }
    webSocketClient.send(response.toString())
}
```

### çœŸæœºæµ‹è¯•åœºæ™¯

**åœºæ™¯1: å‚æ•°ç¼ºå¤±**
```
è¾“å…¥: "è¯·æ˜å¤©çš„å‡"ï¼ˆç¼ºäº‹ç”±ï¼‰
é¢„æœŸ: æ˜¾ç¤ºè¾“å…¥æ¡† â†’ ç”¨æˆ·è¾“å…¥ â†’ ç»§ç»­æ‰§è¡Œ
```

**åœºæ™¯2: å¤šé€‰é¡¹**
```
è¾“å…¥: "è¯·å‡"
é¢„æœŸ: æ˜¾ç¤ºé€‰é¡¹å¯¹è¯æ¡† â†’ ç”¨æˆ·é€‰æ‹© â†’ ç‚¹å‡»æ­£ç¡®æŒ‰é’®
```

**åœºæ™¯3: ç¡®è®¤**
```
è¾“å…¥: "åˆ é™¤æ•°æ®"
é¢„æœŸ: æ˜¾ç¤ºç¡®è®¤å¯¹è¯æ¡† â†’ ç”¨æˆ·å–æ¶ˆ â†’ ä»»åŠ¡åœæ­¢
```

**éªŒæ”¶**: æ‰€æœ‰åœºæ™¯é€šè¿‡ï¼Œæ— å´©æºƒ

---

## é›†æˆæµ‹è¯•æ–¹æ¡ˆ

### æµ‹è¯•åˆ†å±‚

```
æ‰‹åŠ¨æµ‹è¯• (1-2åœºæ™¯)
    â†“
E2Eæµ‹è¯• (5-10åœºæ™¯)
    â†“
é›†æˆæµ‹è¯• (20-30ä¸ª)
    â†“
å•å…ƒæµ‹è¯• (50+ä¸ª)
```

### å…³é”®æµ‹è¯•ç‚¹

**1. å®Œæ•´æµç¨‹**
```python
async def test_complete_flow():
    # å¯åŠ¨ä»»åŠ¡ â†’ è¯¢é—® â†’ å›ç­” â†’ å®Œæˆ
    pass
```

**2. å¹¶å‘**
```python
async def test_concurrent():
    # 3ä¸ªä»»åŠ¡åŒæ—¶è¯¢é—® â†’ ä¾æ¬¡å›ç­” â†’ éƒ½å®Œæˆ
    pass
```

**3. è¶…æ—¶**
```python
async def test_timeout():
    # è¯¢é—® â†’ ä¸å›ç­” â†’ è¶…æ—¶ â†’ ä½¿ç”¨é»˜è®¤å€¼
    pass
```

### CIé…ç½®

```yaml
# .github/workflows/test.yml
- name: Run tests
  run: |
    pytest tests/ -v --cov=droidrun/agent/interaction
```

---

## éªŒæ”¶æ ‡å‡†

| é˜¶æ®µ    | æ ‡å‡†                     |
| ------- | ------------------------ |
| Phase 1 | å•å…ƒæµ‹è¯•è¦†ç›–ç‡ > 90%     |
| Phase 2 | éé˜»å¡æœºåˆ¶æ­£å¸¸ï¼Œè¶…æ—¶æ­£ç¡® |
| Phase 3 | LLMèƒ½è°ƒç”¨ask_user        |
| Phase 4 | å®Œæ•´æµç¨‹é€šè¿‡             |
| Phase 5 | çœŸæœºæµ‹è¯•3ä¸ªåœºæ™¯é€šè¿‡      |

---

## é£é™©æ§åˆ¶

| é£é™©          | ç¼“è§£       |
| ------------- | ---------- |
| WebSocketæ–­è¿ | å®ç°é‡è¿   |
| LLMä¸è°ƒç”¨å·¥å…· | å¼ºåŒ–Prompt |
| å¹¶å‘ç«æ€      | ä½¿ç”¨é”     |

---

## å®æ–½æ—¶é—´çº¿

```
Week 1: Phase 1-2 (åŸºç¡€ + ç®¡ç†å™¨)
Week 2: Phase 3-4 (å·¥å…· + é›†æˆ)
Week 3: Phase 5 (Android + æµ‹è¯•)
```

æ€»è®¡: **10-12ä¸ªå·¥ä½œæ—¥**